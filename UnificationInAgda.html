<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#unification-in-agda">Unification in Agda</a><ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#intro">Intro</a></li>
<li><a href="#imports">Imports</a></li>
<li><a href="#basics-of-type-inference">Basics of type inference</a></li>
<li><a href="#let-where-mutual"><code>let</code>, <code>where</code>, <code>mutual</code></a></li>
<li><a href="#unification-intro">Unification intro</a></li>
<li><a href="#inference-and-pattern-matching">Inference and pattern matching</a></li>
<li><a href="#inference-and-constructors">Inference and constructors</a></li>
<li><a href="#implicit-arguments">Implicit arguments</a></li>
<li><a href="#an-underspecified-argument-example">An underspecified argument example</a></li>
<li><a href="#not-dependent-enough">Not dependent enough</a></li>
<li><a href="#inferring-implicits">Inferring implicits</a></li>
<li><a href="#arguments-of-data-types">Arguments of data types</a><ul>
<li><a href="#comparison-to-haskell">Comparison to Haskell</a></li>
<li><a href="#under-the-hood">Under the hood</a></li>
</ul></li>
<li><a href="#nicer-notation">Nicer notation</a></li>
<li><a href="#type-functions">Type functions</a><ul>
<li><a href="#comparison-to-haskell-1">Comparison to Haskell</a></li>
</ul></li>
<li><a href="#data-constructors">Data constructors</a></li>
<li><a href="#reduction">Reduction</a></li>
<li><a href="#pattern-matching">Pattern matching</a><ul>
<li><a href="#a-constant-argument">A constant argument</a></li>
<li><a href="#a-non-constant-argument">A non-constant argument</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#generalization">Generalization</a></li>
<li><a href="#constructor-headed-functions"><a href="https://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.FindingTheValuesOfImplicitArguments">Constructor-headed functions</a></a></li>
<li><a href="#constructorargument-headed-functions">Constructor/argument-headed functions</a></li>
</ul></li>
<li><a href="#eta-rules">Eta-rules</a><ul>
<li><a href="#computing-predicates-division">Computing predicates: division</a></li>
<li><a href="#bonus-singletons">Bonus: singletons</a></li>
<li><a href="#generating-type-level-data">Generating type-level data</a></li>
</ul></li>
<li><a href="#universe-levels">Universe levels</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
</ul></li>
</ul>
</div>
<pre><style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .agda2-highlight-bound-variable {
      }
      .agda2-highlight-catchall-clause {
        /* agda2-highlight-catchall-clause-face */
        background-color: #f5f5f5;
      }
      .agda2-highlight-coverage-problem {
        /* agda2-highlight-coverage-problem-face */
        background-color: #f5deb3;
      }
      .agda2-highlight-datatype {
        /* agda2-highlight-datatype-face */
        color: #0000cd;
      }
      .agda2-highlight-field {
        /* agda2-highlight-field-face */
        color: #ee1289;
      }
      .agda2-highlight-function {
        /* agda2-highlight-function-face */
        color: #0000cd;
      }
      .agda2-highlight-inductive-constructor {
        /* agda2-highlight-inductive-constructor-face */
        color: #008b00;
      }
      .agda2-highlight-keyword {
        /* agda2-highlight-keyword-face */
        color: #cd6600;
      }
      .agda2-highlight-module {
        /* agda2-highlight-module-face */
        color: #a020f0;
      }
      .agda2-highlight-number {
        /* agda2-highlight-number-face */
        color: #a020f0;
      }
      .agda2-highlight-operator {
      }
      .agda2-highlight-postulate {
        /* agda2-highlight-postulate-face */
        color: #0000cd;
      }
      .agda2-highlight-primitive {
        /* agda2-highlight-primitive-face */
        color: #0000cd;
      }
      .agda2-highlight-primitive-type {
        /* agda2-highlight-primitive-type-face */
        color: #0000cd;
      }
      .agda2-highlight-record {
        /* agda2-highlight-record-face */
        color: #0000cd;
      }
      .agda2-highlight-symbol {
        /* agda2-highlight-symbol-face */
        color: #404040;
      }
      .agda2-highlight-unsolved-constraint {
        /* agda2-highlight-unsolved-constraint-face */
        background-color: #ffff00;
      }
      .agda2-highlight-unsolved-meta {
        /* agda2-highlight-unsolved-meta-face */
        background-color: #ffff00;
      }
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #b22222;
      }
      .default {
        /* default */
        color: #000000;
        background-color: #ffffff;
      }

      code {                               
        white-space: pre;                  
        background-color: #f0f0f0;         
        display: inline-block              
      }                                    
      blockquote {                         
        padding: 0 1em;                    
        color: #6a737d;                    
        border-left: 0.25em solid #d1d5da; 
      }                                    

      a:hover {
        text-decoration: underline;
      }
    -->
    </style></pre>
<h1 id="unification-in-agda">Unification in Agda</h1>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">UnificationInAgda</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>For sources, issue reports or contributing go to <a href="https://github.com/effectfully/unification-in-agda">the GitHub page</a>.</p>
<h2 id="preface">Preface</h2>
<p>Agda is a wonderful language and its unification engines are exemplary, practical, improve over time and work predictably well. Unification engines are one notable distiction between Agda and other dependently typed languages (such as Idris 1, Coq, Lean, etc). I'm saying &quot;unification engines&quot;, because there are two of them:</p>
<ul>
<li>unification used for getting convenient and powerful pattern matching</li>
<li>unification used for inferring values of implicit arguments</li>
</ul>
<p>These are two completely distinct machineries. This tutorial covers only the latter for the moment being. I'll probably say a few words about the former once I forget how hard it is to write long technical texts.</p>
<p>This tutorial primarily targets</p>
<ul>
<li>users of Agda who want to understand how to write code to make more things inferrable</li>
<li>a general audience curious about dependent types and what can be done with them</li>
<li>people implementing powerful dependently typed languages and looking for features to support (most of what is described here are tricks that I use in may day-to-day work (when it involves Agda) and I'd definitely want to see them available in languages that are yet to come)</li>
</ul>
<p>Higher-order unification is not covered. It's a highly advanced topic and from the user's perspective diving into higher-order unification has a rather big cost/benefit ratio: I don't remember tweaking my code to fit it into the pattern fragment or doing anything else of this kind to help Agda unify things in the higher-order case. Agda would barely be usable without the built-in higher-order unification, but it's mostly invisible to the user and just works.</p>
<p>Analogously, no attempt to dissect Agda's internals is performed. Agda is well-designed enough not to force the user to worry about the peculiarities of the implementation (like when something gets postponed or in what order equations get solved). If you do want to learn about the internals, I recommend reading <a href="https://www.researchgate.net/publication/228571999_Type_checking_in_the_presence_of_meta-variables">Type checking in the presence of meta-variables</a> and <a href="http://www.cse.chalmers.se/~abela/unif-sigma-long.pdf">Higher-Order Dynamic Pattern Unification for Dependent Types and Records</a>.</p>
<p>And if you want to learn about internals of unification powering the pattern matching engine, then it's all elaborated in detail by Jesper Cockx in his <a href="https://jesper.sikanda.be/files/thesis-final-digital.pdf">PhD thesis</a>. Section &quot;3.6 Related work&quot; of it shortly describes differences between the requirements for the two kinds of unification.</p>
<h2 id="intro">Intro</h2>
<p>Agda only infers values that are uniquely determined by the current context. I.e. Agda doesn't try to guess: it either fails to infer a value or infers the definitive one. Even though this makes the unification algorithm weaker than it could be, it also makes it reliable and predictable. Whenever Agda infers something, you can be sure that this is the thing that you wanted and not just a random guess that would be different if you provided more information to the type checker (but Agda does have a guessing machinery called <a href="https://agda.readthedocs.io/en/v2.6.0.1/tools/auto.html">Agsy</a> that can be used interactively, so that no guessing needs to be done by the type checker and everything inferred is visible to the user).</p>
<p>We'll look into basics of type inference in Agda and then move to more advanced patterns. But first, some imports:</p>
<h2 id="imports">Imports</h2>
<pre><span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Level</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-primitive">suc</span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-primitive">lsuc</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-primitive">zero</span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-primitive">lzero</span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Function</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-function">_$_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_$&#8242;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8728;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8728;&#8242;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8715;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">case_of_</span></span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-function">_|&gt;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&amp;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_|&gt;&#8242;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&amp;&#8242;_</span></span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Relation.Binary.PropositionalEquality</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Empty</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">&#8869;</span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Unit.Base</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-record">&#8868;</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">tt</span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Bool.Base</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">true</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">false</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-function">not</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8744;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_||_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8743;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&amp;&amp;_</span></span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Nat.Base</span>  <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">zero</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">suc</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_*_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_&#8760;_</span></span><span class="agda2-highlight-symbol">)</span>
<span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Product</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#215;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-record">&#931;</span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_,_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_,&#8242;_</span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<h2 id="basics-of-type-inference">Basics of type inference</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Some preliminaries: the type of lists is defined as (ignoring universe polymorphism)</p>
<pre>  <span class="agda2-highlight-keyword">infixr</span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;_</span></span>

  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-inductive-constructor">[]</span>  <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span>
</pre>
<p>Agda sees <code>[]</code> as having the following type: <code>∀ {A} -&gt; List A</code>, however if you ask Agda what the type of <code>[]</code> is (by creating a hole in this module via <code>_ = ?</code>, putting there <code>[]</code> and typing <code>C-c C-d</code>. Or you can open the current module via <code>open BasicsOfTypeInference</code> and type <code>C-c C-d []</code> without introducing a hole), you'll get something like</p>
<pre><code>  List _A_42</code></pre>
<p>(where <code>42</code> is some arbitrary number that Agda uses to distinguish between variables that have identical textual names, but are bound in distinct places)</p>
<p>That <code>_A_42</code> is a metavariable and Agda expects it to be resolved in the current context. If the context does not provide enough information for resolution to happen, Agda just reports that the metavariable is not resolved, i.e. Agda doesn't accept the code.</p>
<p>In contrast, Haskell is perfectly fine with <code>[]</code> and infers its type as <code>forall a. [a]</code>.</p>
<p>So Agda and Haskell think of <code>[]</code> having the same type</p>
<pre><code>  ∀ {A} -&gt; List A  -- in Agda
  forall a. [a]    -- in Haskell</code></pre>
<p>but Haskell infers this type on the top level unlike Agda which expects <code>A</code> to be either resolved or explicitly bound.</p>
<p>You can make Agda infer the same type that Haskell infers by explicitly binding a type variable via a lambda:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">[]</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span>
</pre>
<p>(<code>_ = &lt;...&gt;</code> is an anonymous definition: we ask Agda to type check something, but don't bother giving it a name, because we're not going to use it later)</p>
<p>This definition is accepted, which means that Agda has inferred its type successfully.</p>
<p>Note that</p>
<pre><code>  _ {A} = [] {A}</code></pre>
<p>means the same thing as the previous expression, but doesn't type check. It's just a syntactic limitation: certain things are allowed in patterns but not in lambdas and vice versa.</p>
<p>Agda can infer monomorphic types directly without any hints:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span>
</pre>
<p>Type inference works not only with lambdas binding implicit arguments, but also explicit ones. And types of latter arguments can depend on earlier arguments. E.g.</p>
<pre>  <span class="agda2-highlight-function">id&#8321;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>is the regular <code>id</code> function spelled as</p>
<pre><code>  id :: forall a. a -&gt; a
  id x = x</code></pre>
<p>in Haskell.</p>
<p>Partially or fully applied <code>id₁</code> doesn't need a type signature either:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#8321;</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#8321;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">}</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#8321;</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<p>You can even interleave implicit and explicit arguments and partial applications (and so full ones as well) will still be inferrable:</p>
<pre>  <span class="agda2-highlight-function">const</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">const</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">}</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">const</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<p>Finally, you don't need to specify a type signature for an alias, even if that alias has a different fixity than what it's defined in terms of. My favourite example is this:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8728;</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8728;_</span></span>
</pre>
<p>It's an operator that allows us to compose a function with an n-ary function. In Haskell we have libraries like <a href="https://hackage.haskell.org/package/composition">composition</a> that define a bunch of n-ary composition operators like</p>
<pre><code>  (.*) :: (c -&gt; d) -&gt; (a -&gt; b -&gt; c) -&gt; a -&gt; b -&gt; d
  (.**) :: (d -&gt; e) -&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; e
  etc</code></pre>
<p>but in Agda we can get away with a single additional postfix operator and construct all of the above on the fly. For example:</p>
<pre>  <span class="comment">-- Composing `suc` with 2-ary `_+_`</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span>

  <span class="comment">-- Composing `suc` with a random 3-ary function.</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-function">f</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-function">f</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-number">0</span>
</pre>
<p>Note that <code>_∘</code> and <code>_∘_</code> are two different operators (in particular, the former is postfix and the latter is infix) that happen to be called the same. We could have called <code>_∘</code> differently of course, but since Agda is able to distinguish between the two based on how they're used (there's no <code>∘_</code> and so Agda knows that the only way to parse <code>suc ∘ ∘ ∘ f</code> is <code>((suc ∘) ∘) ∘ f</code>, which is exactly what one'd write in Haskell), it's just nice to make the two operators share the name.</p>
<h2 id="let-where-mutual"><code>let</code>, <code>where</code>, <code>mutual</code></h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">LetWhereMutual</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>In Agda bindings that are not marked with <code>abstract</code> are transparent, i.e. writing, say, <code>let v = e in b</code> is the same thing as directly substituting <code>e</code> for <code>v</code> in <code>b</code> (<code>[e/v]b</code>). For example all of these type check:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-keyword">let</span> <span class="agda2-highlight-bound-variable">&#120121;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
          <span class="agda2-highlight-bound-variable">t</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">&#120121;</span>
          <span class="agda2-highlight-bound-variable">t</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
      <span class="agda2-highlight-keyword">in</span> <span class="agda2-highlight-bound-variable">t</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">t</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-function">&#120121;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
    <span class="agda2-highlight-function">t</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">&#120121;</span>
    <span class="agda2-highlight-function">t</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>

  <span class="agda2-highlight-function">&#120121;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-function">t</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">&#120121;</span>
  <span class="agda2-highlight-function">t</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">t</span>
</pre>
<p>Unlike Haskell Agda does not have <a href="https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html">let-generalization</a>, i.e. this valid Haskell code:</p>
<pre><code>  p :: (Bool, Integer)
  p = let i x = x in (i True, i 1)</code></pre>
<p>has to be written either with an explicit type signature for <code>i</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#215;</span></span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-keyword">let</span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
          <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
      <span class="agda2-highlight-keyword">in</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-inductive-constructor">true</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>or in an equivalent way like</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#215;</span></span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-keyword">let</span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
      <span class="agda2-highlight-keyword">in</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-inductive-constructor">true</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>So Agda infers polymorphic types neither on the top level nor locally.</p>
<p>In Haskell types of bindings can be inferred from how those bindings are used later. E.g. the inferred type of a standalone</p>
<pre><code>  one = 1</code></pre>
<p>is <code>Integer</code> (see <a href="https://wiki.haskell.org/Monomorphism_restriction">monomorphism restriction</a>), but in</p>
<pre><code>  one = 1
  one&#39; = one :: Word</code></pre>
<p>the inferred type of <code>one</code> is <code>Word</code> rather than <code>Integer</code>.</p>
<p>This is not the case in Agda, e.g. a type for</p>
<pre><code>  i = λ x -&gt; x</code></pre>
<p>is not going to be inferred regardless of how this definition is used later. However if you use <code>let</code>, <code>where</code> or <code>mutual</code> inference is possible:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-keyword">let</span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-keyword">in</span> <span class="agda2-highlight-bound-variable">i</span> <span class="agda2-highlight-inductive-constructor">true</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">i</span> <span class="agda2-highlight-inductive-constructor">true</span> <span class="agda2-highlight-keyword">where</span> <span class="agda2-highlight-function">i</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>

  <span class="agda2-highlight-keyword">mutual</span>
    <span class="agda2-highlight-function">i</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
    <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">i</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<p>In general, definitions in a <code>let</code>/<code>where</code>/<code>mutual</code> block share the same context, which makes it possible to infer more things than with consecutive standalone definitions. It's occasionally useful to create a bogus <code>mutual</code> block when you want the type of a definition to be inferred based on its use.</p>
<h2 id="unification-intro">Unification intro</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">UnificationIntro</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>The following definitions type check:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-number">1</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-number">2</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-number">1</span>
</pre>
<p>reassuring that Agda's type checker is not based on some simple bidirectional typing rules (if you're not familier with those, see <a href="http://www.davidchristiansen.dk/tutorials/bidirectional.pdf">Bidirectional Typing Rules: A Tutorial</a>), but the type checker does have a bidirectional interface (<a href="https://hackage.haskell.org/package/Agda-2.6.1/docs/Agda-TheTypeChecker.html#v:inferExpr"><code>inferExpr</code></a> &amp; <a href="https://hackage.haskell.org/package/Agda-2.6.1/docs/Agda-TheTypeChecker.html#v:checkExpr"><code>checkExpr</code></a>) where type inference is defined in terms of type checking for the most part:</p>
<pre><code>  -- | Infer the type of an expression. Implemented by checking against a meta variable. &lt;...&gt;
  inferExpr :: A.Expr -&gt; TCM (Term, Type)</code></pre>
<p>which means that any definition of the following form:</p>
<pre><code>  name = term</code></pre>
<p>can be equally written as</p>
<pre><code>  name : _
  name = term</code></pre>
<p>since Agda elaborates <code>_</code> to a fresh metavariable and then type checks <code>term</code> against it, which amounts to unifying the inferred type of <code>term</code> with the meta. If the inferred type doesn't contain metas itself, then the meta standing for <code>_</code> is resolved as that type and the definition is accepted (if the inferred type does contain metas, things get more difficult and we're not going to describe all the gory details here). So type inference is just a particular form of unification.</p>
<p>You can put <code>_</code> basically anywhere and let Agda infer what term/type it stands for. For example:</p>
<pre>  <span class="agda2-highlight-function">id&#8322;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-function">id&#8322;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>Here Agda binds the <code>x</code> variable and records that it has type <code>A</code> and when the <code>x</code> variable is returned as a result, Agda unifies the expected type <code>_</code> with the actual type of <code>x</code>, which is <code>A</code>. Thus the definition above elaborates to</p>
<pre>  <span class="agda2-highlight-function">id&#8322;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id&#8322;&#8242;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>This definition:</p>
<pre>  <span class="agda2-highlight-function">id&#8323;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id&#8323;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>elaborates to the same result in a similar fashion, except now Agda first records that the type of <code>x</code> is a meta and when <code>x</code> is returned as a result, Agda unifies that meta with the expected type, i.e. <code>A</code>, and so the meta gets resolved as <code>A</code>.</p>
<p>An <code>id</code> function that receives an explicit type:</p>
<pre>  <span class="agda2-highlight-function">id&#8324;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id&#8324;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>can be called as</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#8324;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<p>and the <code>_</code> will be inferred as <code>Bool</code>.</p>
<p>It's also possible to explicitly specify an implicit type by <code>_</code>, which is essentially a no-op:</p>
<pre>  <span class="agda2-highlight-function">id&#8325;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id&#8325;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#8325;</span> <span class="agda2-highlight-symbol">{_}</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<h2 id="inference-and-pattern-matching">Inference and pattern matching</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">InferenceAndPatternMatching</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Unrestricted pattern matching breaks type inference. Take for instance</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">_</span></span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">&#955;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-keyword"><span class="agda2-highlight-unsolved-meta">where</span></span>
          <span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">zero</span></span><span class="agda2-highlight-unsolved-meta">    </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">-&gt;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">true</span></span>
          <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">(</span></span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">suc</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_)</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">-&gt;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">false</span></span>
</pre>
<p>which is a direct counterpart of Haskell's</p>
<pre><code>  isZero = \case
      0 -&gt; True
      _ -&gt; False</code></pre>
<p>The latter is accepted by Haskell, but the former is not accepted by Agda: Agda colors the entire snippet in yellow meaning it's unable to resolve the generated metavariables. &quot;What's the problem? The inferred type should be just <code>ℕ -&gt; Bool</code>&quot; -- you might think. Such a type works indeed:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">true</span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">false</span>
</pre>
<p>But here's another thing that works:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&amp;</span></span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
                         <span class="agda2-highlight-inductive-constructor">zero</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
                         <span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">true</span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">false</span>
</pre>
<p>Recall that we're in a dependently typed language and here the type of the result of a function can depend on the argument of that function. And both the</p>
<pre><code>  ℕ -&gt; Bool

  (n : ℕ) -&gt; n &amp; λ where
                     zero -&gt; Bool
                     _    -&gt; Bool</code></pre>
<p>types are correct for that function. Even though they are &quot;morally&quot; the same, they are not definitionally equal and there's a huge difference between them: the former one doesn't have a dependency and the latter one has.</p>
<p>There is a way to tell Agda that pattern matching is non-dependent: use <code>case_of_</code>, e.g.</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">case</span></span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">of</span></span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">true</span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">false</span>
</pre>
<p>type checks. <code>case_of_</code> is just a definition in the standard library that at the term level is essentially</p>
<pre><code>  case x of f = f x</code></pre>
<p>and at the type level it restricts the type of <code>f</code> to be a non-dependent function.</p>
<p>Analogously, this is yellow:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">&amp;</span></span></span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">true</span></span></span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">false</span></span></span>
</pre>
<p>due to <code>_&amp;_</code> being dependent:</p>
<pre><code>  _&amp;_ : {A : Set} {B : A -&gt; Set} -&gt; ∀ x -&gt; (∀ x -&gt; B x) -&gt; B x
  x &amp; f = f x</code></pre>
<p>While this is fine:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&amp;&#8242;</span></span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">true</span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">false</span>
</pre>
<p>due to <code>_&amp;′_</code> being non-dependent:</p>
<pre><code>  _&amp;′_ : {A B : Set} -&gt; A -&gt; (A -&gt; B) -&gt; B
  x &amp;′ f = f x</code></pre>
<p>Agda's stdlib provides several intentionally non-dependent functions (e.g. <code>_∘′_</code>, <code>_$′_</code> and <code>case_of_</code> that we've already seen) to enable the user to get improved inference in the non-dependent case.</p>
<p>Note that annotating <code>n</code> with its type, <code>ℕ</code>, is mandatory in all the cases above. Agda is not able to conclude that if a value is matched against a pattern, then the value must have the same type as the pattern.</p>
<p>Even this doesn't type check:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">&#955;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">-&gt;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">case</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">of</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">&#955;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-keyword"><span class="agda2-highlight-unsolved-meta">where</span></span>
          <span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">zero</span></span><span class="agda2-highlight-unsolved-meta">    </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">-&gt;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">zero</span></span>
          <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">(</span></span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">suc</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">)</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">-&gt;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span>
</pre>
<p>even though Agda really could figure out that if <code>zero</code> is returned from one of the branches, then the type of the result is <code>ℕ</code>, and since <code>n</code> is returned from the other branch and pattern matching is non-dependent, <code>n</code> must have the same type. See <a href="https://github.com/agda/agda/issues/2834">#2834</a> for why Agda doesn't attempt to be clever here.</p>
<p>There's a funny syntactical way to tell Agda that a function is non-dependent: just do not bind a variable at the type level. This type checks:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">true</span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">false</span>
</pre>
<p>while this doesn't:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-keyword">where</span>
          <span class="agda2-highlight-inductive-constructor">zero</span>    <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">true</span></span></span>
          <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">false</span></span></span>
</pre>
<p>In the latter case Agda treats <code>_</code> as being potentially dependent on <code>n</code>, since <code>n</code> is explicitly bound. And in the former case there can't be any dependency on a non-existing variable.</p>
<h2 id="inference-and-constructors">Inference and constructors</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">InferenceAndConstructors</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Since tuples are dependent, this</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">,</span></span></span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>results in unresolved metas as all of these</p>
<pre><code>  ℕ × ℕ

  Σ ℕ λ where
          zero -&gt; ℕ
          _    -&gt; ℕ

  Σ ℕ λ where
          1 -&gt; ℕ
          _ -&gt; Bool</code></pre>
<p>are valid types for this expression, which is similar to what we've considered in the previous section, except here not all of the types are &quot;morally the same&quot;: the last one is very different to the first two.</p>
<p>As in the case of functions you can use a non-dependent alternative</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">,&#8242;</span></span> <span class="agda2-highlight-number">2</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>(<code>_,′_</code> is a non-dependent version of <code>_,_</code>)</p>
<p>to tell Agda not to worry about potential dependencies.</p>
<h2 id="implicit-arguments">Implicit arguments</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">ImplicitArgumens</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>As we've seen implicit arguments and metavariables are closely related. Agda's internal theory has metas in it, so inference of implicit arguments amounts to turning an implicit into a metavariable and resolving it later. The complicated part however is that it's not completely obvious where implicits get inserted.</p>
<p>For example, it may come as a surprise, but</p>
<pre><code>  _ : ∀ {A : Set} -&gt; A -&gt; A
  _ = λ {A : Set} x -&gt; x</code></pre>
<p>gives a type error. This is because Agda greedily binds implicits, so the <code>A</code> at the term level gets automatically bound on the lhs (left-hand side, i.e. before <code>=</code>), which gives you essentially this:</p>
<pre><code>  _ : ∀ {A : Set} -&gt; A -&gt; A
  _ {_} = &lt;your_code_goes_here&gt;</code></pre>
<p>where <code>{_}</code> stands for <code>{A}</code>. So you can't bind <code>A</code> by a lambda, because it's already silently bound for you. Although it's impossible to reference that type variable unless you explicitly name it as in</p>
<pre>  <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>Not only does Agda eagerly binds implicits, but it also inserts them eagerly at the call site. E.g.</p>
<pre>  <span class="agda2-highlight-function">id-id</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id-id</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-function">id</span>
</pre>
<p>elaborates to</p>
<pre>  <span class="agda2-highlight-function">id-id&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id-id&#8321;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">id</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">})</span>
</pre>
<p>I.e. the inner <code>id</code> gets implicitly instantiated and only then fed to the outer <code>id</code>. Hence the outer <code>id</code> is instantiated at <code>A -&gt; A</code>, which is the type of the inner instantiated <code>id</code>.</p>
<p>An alternative could be</p>
<pre><code>  id-id₂ : {A : Set} -&gt; A -&gt; A
  id-id₂ {A} = id { {A : Set} -&gt; A -&gt; A } id {A}</code></pre>
<p>Here the inner <code>id</code> doesn't get instantiated and gets fed to the outer <code>id</code> as is. Hence the outer <code>id</code> is instantiated at <code>{A : Set} -&gt; A -&gt; A</code>, which is the type of the inner uninstantiated <code>id</code>.</p>
<p>(Except that definition does not type check, because <code>{A : Set} -&gt; A -&gt; A</code> is of type <code>Set₁</code> rather than <code>Set</code> and we don't bother fixing this with proper universe polymorphism as those details are irrelevant for explaining how implicits get inserted)</p>
<p>Eager insertion of implicits is the reason why Agda infers the type of <code>[]</code> as <code>List _A_42</code>: <code>[]</code> gets elaborated to <code>[] {_}</code>, because the explicit argument <code>A</code> of <code>List</code> is implicit for the constructors of <code>List</code> (i.e. <code>[]</code> and <code>_∷_</code>) and that implicit gets eagerly inserted.</p>
<p>One exception to the general rule that implicits get bound and inserted eagerly is aliases: a definition of the form <code>&lt;name1&gt; = &lt;name2&gt;</code> doesn't need a type signature (as we saw before with the <code>_∘ = _∘_</code> example) and gets accepted as is regardless of whether <code>&lt;name2&gt;</code> has any leading implicit arguments or not. Basically, <code>&lt;name1&gt;</code> inherits its type signature from <code>&lt;name2&gt;</code> without any further elaboration.</p>
<p>There is a notorious bug related to insertion of implicit lambdas that has been in Agda for ages (even since its creation probably?) called The Hidden Lambda Bug. I'm not going to describe the bug here as details change across different version of Agda, but here are some links:</p>
<ul>
<li>tracked in <a href="https://github.com/agda/agda/issues/1079">this issue</a></li>
<li>discussed in detail in <a href="https://github.com/agda/agda/issues/2099">this issue</a></li>
<li>there's even an entire <a href="http://www2.tcs.ifi.lmu.de/~abel/MScThesisJohanssonLloyd.pdf">MSc thesis</a> about it</li>
<li>and a <a href="https://github.com/AndrasKovacs/implicit-fun-elaboration/blob/master/paper.pdf">plausible solution</a></li>
</ul>
<p>So while Agda's elaborations works well, it has its edge cases. In practice, it's not a big deal to insert an implicit lambda to circumvent the bug, but it's not always clear that Agda throws a type error because of this bug and not due to something else (e.g. I was completely lost in <a href="https://github.com/agda/agda/issues/1095">this case</a>). So beware.</p>
<h2 id="an-underspecified-argument-example">An underspecified argument example</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">UnderspecifiedArgument</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Another difference between Haskell and Agda is that Agda is not happy about ambiguous types that don't really affect anything. Consider a classic example: the <code>I</code> combinator can be defined in terms of the <code>S</code> and <code>K</code> combinators. In Haskell we can express that as</p>
<pre><code>  k :: a -&gt; b -&gt; a
  k x y = x

  s :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
  s f g x = f x (g x)

  i :: a -&gt; a
  i = s k k</code></pre>
<p>and <a href="https://ideone.com/mZQM1f">it'll type check</a>. However the Agda's equivalent</p>
<pre>  <span class="agda2-highlight-function">K</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">K</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>

  <span class="agda2-highlight-function">S</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">C</span>
  <span class="agda2-highlight-function">S</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-bound-variable">g</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">g</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span>

  <span class="agda2-highlight-function">I</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">I</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">S</span> <span class="agda2-highlight-function">K</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">K</span></span>
</pre>
<p>results in the last <code>K</code> being highlighted in yellow (which means that not all metavariables were resolved). To see why, let's inline <code>S</code> and see if the problem persists:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">K</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">K</span></span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>It does. So the problem is that in the expression above the final <code>K x</code> argument is underspecified: a <code>K</code> must receive a particular <code>B</code>, but we neither explicitly specify a <code>B</code>, nor it can be inferred from the context as the entire <code>K x</code> argument is thrown away by the outer <code>K</code>.</p>
<p>To fix this we can explicitly specify a <code>B</code> (any of type <code>Set</code> will work, let's pick <code>ℕ</code>):</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">S</span> <span class="agda2-highlight-function">K</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">K</span> <span class="agda2-highlight-symbol">{</span>B <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">})</span>
</pre>
<p>In general, Agda expects all implicits (and metavariables in general) to be resolved and won't gloss over such details the way Haskell does. Agda is a proof assistant and under the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a> each argument to a function represents a certain logical assumption and every such assumption must be fulfilled at the call site either explicitly or in an automated manner.</p>
<h2 id="not-dependent-enough">Not dependent enough</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">NotDependentEnough</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Speaking of <code>K</code>, what do you think its most general type is, in Agda? Recall that we were using this definition in the previous section:</p>
<pre>  <span class="agda2-highlight-function">K&#8320;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">K&#8320;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>Looking at that type signature, we can think of making the type of the second argument dependent on the first argument:</p>
<pre>  <span class="agda2-highlight-function">K&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
</pre>
<p>This version looks more general, but it's in fact not, as <code>K₁</code> can be expressed in terms of <code>K₀</code>:</p>
<pre>  <span class="agda2-highlight-function">K&#8321;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">K&#8320;</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>Basically, if you have an <code>x</code> to pass to <code>K₀</code>, then you can use that same <code>x</code> to apply a <code>B : A -&gt; Set</code> to it to get <code>B x</code> of type <code>Set</code> and since the non-dependent <code>K</code> does not restrict the type of its second argument in any way, <code>B x</code> is good enough, and the fact that it mentions the particular <code>x</code> being passed as a first term-level argument, is just irrelevant. If we fully spell it out:</p>
<pre>  <span class="agda2-highlight-function">K&#8321;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">K&#8321;&#8242;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">K&#8320;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>Note that we had to eta-expand the definition of <code>K₁</code>. If we don't do that, we'll get an error:</p>
<pre><code>  -- Cannot instantiate the metavariable _360 to solution B x
  -- since it contains the variable x
  -- which is not in scope of the metavariable
  K₁ : {A : Set} {B : A -&gt; Set} -&gt; ∀ x -&gt; B x -&gt; A
  K₁ = K₀</code></pre>
<p>This is because this definition of <code>K₁</code> elaborates to <code>K₁ {_} {_} = K₀ {_} {_}</code> due to eager insertion of implicits and the last <code>_</code> can't be resolved, because as we can see in <code>K₁′</code> it has to be <code>B x</code>, but <code>x</code> is not bound on the lhs and so Agda complains about it.</p>
<p><code>K₀</code> in turn can be expressed in terms of <code>K₁</code>:</p>
<pre>  <span class="agda2-highlight-function">K&#8320;-via-K&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">K&#8320;-via-K&#8321;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">K&#8321;</span>
</pre>
<p>Basically, <code>K₁</code> expects a <code>A -&gt; Set</code> and we can create one from <code>B : Set</code> via <code>λ _ -&gt; B</code>.</p>
<p>So <code>K₀</code> and <code>K₁</code> are equally powerful. And note how in both the <code>K₀</code>-via-<code>K₁</code> and <code>K₁</code>-via-<code>K₀</code> cases Agda successfully infers implicits.</p>
<p>So is <code>K₀</code>/<code>K₁</code> the best we can do? Nope, here's a twist: we can make the type of the result depend on the second argument (the one that gets dropped), which in turn requires to reflect the dependency in the type of the first argument (the one that gets returned), so we end up with</p>
<pre>  <span class="comment">-- &#7496; for "dependent".</span>
  <span class="agda2-highlight-function">K&#7496;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span>
  <span class="agda2-highlight-function">K&#7496;</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>Compare this to regular function application:</p>
<pre>  <span class="agda2-highlight-function">apply</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span>
  <span class="agda2-highlight-function">apply</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>I.e. <code>Kᵈ</code> is implicit function application.</p>
<p>&quot;You're making it up! <code>Kᵈ</code> elaborates to <code>λ y x -&gt; y {x}</code>, how is that a <code>K</code> combinator?&quot;</p>
<p>Here is how: first of all, <code>K₀</code> can be directly defined via <code>Kᵈ</code>:</p>
<pre>  <span class="agda2-highlight-function">K&#8320;-via-K&#7496;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">K&#8320;-via-K&#7496;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">K&#7496;</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>But most importantly <code>Kᵈ</code> expresses the &quot;drop the second argument, return the first one&quot; idea better than than the non-dependent <code>K</code> as the former can be used where the latter fails. For example, in the <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.379.3169&amp;rep=rep1&amp;type=pdf">Outrageous but Meaningful Coincidences</a> paper the author stumbles upon a few expressions involving <code>K</code> that look like they should type check, but they don't, despite the fact that a bunch of very similar expressions also involving <code>K</code> type check perfectly well. So the author inlines the definition of <code>K</code> and writes in a footnote:</p>
<blockquote>
<p>It’s frankly astonishing how effective Agda’s implicit syntax mechanism turns out to be. The trouble is that the system’s limits are far from clear. It is hard to tell what shouldn’t work, and what is rather a lacuna.</p>
</blockquote>
<p>However in this case the problem is not with Agda not being able to infer something, but rather the type of <code>K</code> being too restrictive. If we use the dependent version of <code>K</code> instead, then <a href="https://github.com/effectfully/random-stuff/blob/07253f395c63813abb64a08045e22ae8412e5be6/Kipling.agda#L110-L114">everything type checks</a>.</p>
<p>Note that we had to eta-expand <code>K₀-via-Kᵈ</code>, but this time for a different reason. If we make it</p>
<pre><code>  K₀-via-Kᵈ′ : {A B : Set} -&gt; A -&gt; B -&gt; A
  K₀-via-Kᵈ′ {A} {B} = {!Kᵈ {B} {λ _ -&gt; A}!}</code></pre>
<p>and ask for the type of the expression in the hole, we'll see</p>
<pre><code>  Goal: A -&gt; B -&gt; A
  Have: ({B} -&gt; A) -&gt; B -&gt; A</code></pre>
<p>and <code>A</code> and <code>{B} -&gt; A</code> are two distinct types that fail to unify. While an expression of type <code>A</code> can be used wherever a <code>{B} -&gt; A</code> is expected as Agda will realize that an implicit variable of type <code>B</code> can be simply ignored, and so this is why eta-expaning the definition solves the problem.</p>
<p>Is <code>Kᵈ</code> the best we can do? Well, Agda has explicit universe polymorphism, so we can and should make the definition universe-polymorphic:</p>
<pre>  <span class="agda2-highlight-function">K&#7496;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span>
  <span class="agda2-highlight-function">K&#7496;&#8242;</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>Which gives us a reasonably general definition that works in most practical cases, but here's an example of where it fails:</p>
<pre><code>  -- Set (lsuc (lsuc α)) != Set _β_382
  -- when checking that the expression Set α has type Set (lsuc α)
  _ = Kᵈ′ (λ {α} -&gt; Set α)</code></pre>
<p>This is because the type of <code>Set α</code> is <code>Set (lsuc α)</code> where <code>α</code> is an (implicit) argument, i.e. the universe where <code>B</code> lies depends on the received value and <code>Kᵈ′</code> does not support this due to <code>β</code> not depending on an <code>A</code> in the type of <code>B</code>: <code>A -&gt; Set β</code>.</p>
<p>We can support this use case by turning <code>β</code> into a function from <code>A</code>:</p>
<pre>  <span class="agda2-highlight-function">K&#7496;&#8242;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-postulate">Level</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span>
  <span class="agda2-highlight-function">K&#7496;&#8242;&#8242;</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>Now the example type checks:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">K&#7496;&#8242;&#8242;</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>But that is rarely needed in practice and not making <code>β</code> a function is good enough most of the time.</p>
<p>In general, an attempt to apply a higher-order function expecting a non-dependent function as its argument to a dependent function results in an error talking about a variable not being in scope of a metavariable. As a quick example, having a random dependently typed function:</p>
<pre>  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span>

  <span class="agda2-highlight-function">falseOrZero</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-bound-variable">b</span>
  <span class="agda2-highlight-function">falseOrZero</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">false</span>
  <span class="agda2-highlight-function">falseOrZero</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
</pre>
<p>we can trigger the error by trying to feed <code>falseOrZero</code> to <code>_$′_</code> (which expects a non-dependent function):</p>
<pre><code>  -- Cannot instantiate the metavariable _401 to solution BoolOrℕ b
  -- since it contains the variable b
  -- which is not in scope of the metavariable
  _ = falseOrZero $′ true</code></pre>
<p>The exact error message depends on the version of Agda used, though.</p>
<p>But note that</p>
<ol style="list-style-type: decimal">
<li>this error can be triggered in different cases as well, as we saw with <code>K₁ = K₀</code></li>
<li>applying a higher-order function to an unexpectedly dependent function can give a different error, as we saw with <code>Kᵈ′′ (λ {α} -&gt; Set α)</code></li>
</ol>
<p>Anyway, in my experience being able to make sense of that particular error is really helpful.</p>
<h2 id="inferring-implicits">Inferring implicits</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">InferringImplicits</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>As we've seen previously the following code type checks fine:</p>
<pre>  <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id</span> <span class="agda2-highlight-inductive-constructor">true</span>
</pre>
<p>Here <code>A</code> is bound implicitly in <code>id</code>, but Agda is able to infer that in this case <code>A</code> should be instantiated to <code>Bool</code> and so Agda elaborates the expression to <code>id {Bool} true</code>.</p>
<p>This is something that Haskell would infer as well. The programmer would hate to explicitly write out the type of every single argument, so programming languages often allow the user not to specify types when they can be inferred from the context. Agda is quite unique here however, because it can infer a lot more than other languages (even similar dependently typed ones) due to bespoke machineries handling various common patterns. But let's start with the basics.</p>
<h2 id="arguments-of-data-types">Arguments of data types</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">ArgumentsOfDataTypes</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span>
</pre>
<p>Agda can infer parameters/indices of a data type from a value of that data type. For example if you have a function</p>
<pre>  <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>then the implicit <code>A</code> can be inferred from a list:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Unless, of course, <code>A</code> can't be determined from the list alone. E.g. if we pass an empty list to <code>f</code>, Agda will mark <code>listId</code> with yellow and display an unresolved metavariable <code>_A</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">listId</span></span> <span class="agda2-highlight-inductive-constructor">[]</span>
</pre>
<p>Another example of this situation is when the list is not empty, but the type of its elements can't be inferred, e.g.</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">x</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Here the type of <code>x</code> can be essentially anything (<code>ℕ</code>, <code>List Bool</code>, <code>⊤ × Bool -&gt; ℕ</code>, etc), so Agda asks to provide missing details. Which we can do either by supplying a value for the implicit argument explicitly</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>or by annotating <code>x</code> with a type</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>or just by providing a type signature</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>All these definitions are equivalent.</p>
<p>So &quot;<code>A</code> is inferrable from a <code>List A</code>&quot; doesn't mean that you can pass any list in and magically synthesize the type of its elements -- only that if that type is already known at the call site, then you don't need to explicitly specify it to apply <code>listId</code> to the list as it'll be inferred for you. &quot;Already known at the call site&quot; doesn't mean that the type of elements needs to be inferrable -- sometimes it can be derived from the context, for example:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>The implicit <code>A</code> gets inferred here: since all elements of a list have the same type, the type of <code>λ x -&gt; x</code> must be the same as the type of <code>suc</code>, which is known to be <code>ℕ -&gt; ℕ</code>, hence the type of <code>λ x -&gt; x</code> is also <code>ℕ -&gt; ℕ</code>.</p>
<h3 id="comparison-to-haskell">Comparison to Haskell</h3>
<p>In Haskell it's also the case that <code>a</code> is inferrable form a <code>[a]</code>: when the programmer writes</p>
<pre><code>`  sort :: Ord a =&gt; [a] -&gt; [a]</code></pre>
<p>Haskell is always able to infer <code>a</code> from the given list (provided <code>a</code> is known at the call site: <code>sort []</code> is as meaningless in Haskell as it is in Agda) and thus figure out what the appropriate <code>Ord a</code> instance is. However, another difference between Haskell and Agda is that whenever Haskell sees that some implicit variables (i.e. those bound by <code>forall &lt;list_of_vars&gt; .</code>) can't be inferred in the general case, Haskell, unlike Agda, will complain. E.g. consider the following piece of code:</p>
<pre><code>  {-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, TypeFamilies #-}

  class C a b where
    f :: a -&gt; Int

  instance b ~ () =&gt; C Bool b where
    f _ = 0

  main = print $ f True</code></pre>
<p>Even though at the call site (<code>f True</code>) <code>b</code> is determined via the <code>b ~ ()</code> constraint of the <code>C Bool b</code> instance and so there is no ambiguity, Haskell still complains about the definition of the <code>C</code> class itself:</p>
<pre><code>  • Could not deduce (C a b0)
    from the context: C a b
      bound by the type signature for:
                 f :: forall a b. C a b =&gt; a -&gt; Int
      at prog.hs:6:3-15
    The type variable ‘b0’ is ambiguous</code></pre>
<p>The type of the <code>f</code> function mentions the <code>b</code> variable in the <code>C a b</code> constraint, but that variable is not mentioned anywhere else and hence can't be inferred in the general case, so Haskell complains, because by default it wants all type variables to be inferrable upfront regardless of whether at the call site it would be possible to infer a variable in some cases or not. We can override the default behavior by enabling the <code>AllowAmbiguousTypes</code> extension, which makes the code type check without any additional changes.</p>
<p>Agda's unification capabilities are well above Haskell's ones, so Agda doesn't attempt to predict what can and can't be inferred and allows us to make anything implicit, deferring resolution problems to the call site (i.e. it's like having <code>AllowAmbiguousTypes</code> globally enabled in Haskell). In fact, you can make implicit even such things that are pretty much guaranteed to never have any chance of being inferred, for example</p>
<pre>  <span class="agda2-highlight-function">const-zero&#7522;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>  <span class="comment">-- `{&#8469;}` is a shorthand for `{_ : &#8469;}`</span>
  <span class="agda2-highlight-function">const-zero&#7522;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">zero</span>
</pre>
<p>as even</p>
<pre>  <span class="agda2-highlight-function">const-zero&#7522;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">const-zero&#7522;&#8242;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">const-zero&#7522;</span></span>
</pre>
<p>results in unresolved metas, because it elaborates to</p>
<pre>  <span class="agda2-highlight-function">const-zero&#7522;&#8242;-elaborated</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">const-zero&#7522;&#8242;-elaborated</span> <span class="agda2-highlight-symbol">{_}</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">const-zero&#7522;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span><span class="agda2-highlight-symbol">}</span>
</pre>
<p>(due to eager insertion of implicits) and the fact that there's a variable of type <code>ℕ</code> bound in the current scope (regardless of whether it's bound explicitly or implicitly) does not have any effect on how implicits get resolved in the body of the definition. Metavariable resolution does not come up with instantiations for metavariables at random by looking at the local or global scope, it only determines what instantiations are bound to be by solving unification problems that arise during type checking.</p>
<p>But note that even though a value of type <code>{ℕ} -&gt; ℕ</code> is not very useful on its own, having such a value as an argument like this:</p>
<pre>  <span class="agda2-highlight-function">at1</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">({</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">at1</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span>
</pre>
<p>can be useful occasionally, because it gives you an API where the caller can decide if they want to bind the additional implicit variable or not. Here's an example for each of the cases:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">at1</span> <span class="agda2-highlight-number">2</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">at1</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span>
</pre>
<p>Thus, <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)#Function_types">covariantly positioned</a> implicits that are not determined by explicit arguments can be handy for providing defaults or additional data that the caller is usually not interested in, but occasionally is, and so the data is hidden in an implicit.</p>
<p>By the way, if you do need to resolve things based on the current scope, then Agda has <a href="https://agda.readthedocs.io/en/latest/language/instance-arguments.html">instance arguments</a> for that (they are similar to Haskell's type classes, but do not obey <a href="http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness">global uniqueness of instances</a>, because <a href="https://github.com/AndrasKovacs/pny1-assignment/blob/292e0fc28d7c27b35240d4f9d014bdf4db3afc62/DepTC.md#4-coherent-classes-in-dependent-languages">it's hard</a>), for example</p>
<pre>  <span class="agda2-highlight-function">const-zero&#7522;&#7522;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">const-zero&#7522;&#7522;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">zero</span>

  <span class="agda2-highlight-function">const-zero&#7522;&#7522;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="comment">-- Explicitly inserting `{{_}}` just to show that there's no interference with how instance</span>
  <span class="comment">-- arguments get inserted.</span>
  <span class="agda2-highlight-function">const-zero&#7522;&#7522;&#8242;</span> <span class="agda2-highlight-symbol">{{_}}</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">const-zero&#7522;&#7522;</span>
</pre>
<p>does not result in unresolved metas.</p>
<h3 id="under-the-hood">Under the hood</h3>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">UnderTheHood</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span>
</pre>
<h4 id="example-1-listid-1-2">Example 1: <code>listId (1 ∷ 2 ∷ [])</code></h4>
<p>Returning to our <code>listId</code> example, when the user writes</p>
<pre>  <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>here is what happens under the hood:</p>
<ol style="list-style-type: decimal">
<li>the implicit <code>A</code> gets instantiated as a metavariable <code>_A</code></li>
<li>the type of the instantiated <code>listId</code> becomes <code>List _A -&gt; List _A</code></li>
<li><code>List _A</code> (what the instantiated <code>listId</code> expects as an argument) gets unified with <code>List ℕ</code> (the type of the actual argument). We'll write this as <code>List _A =?= List ℕ</code></li>
<li>From unification's point of view type constructors are injective, hence <code>List _A =?= List ℕ</code> simplifies to <code>_A =?= ℕ</code>, which immediately gets solved as <code>_A := ℕ</code></li>
</ol>
<p>And this is how Agda figures out that <code>A</code> gets instantiated by <code>ℕ</code>.</p>
<h4 id="example-2-suc-listid-λ-x---x">Example 2: <code>suc ∷ listId ((λ x -&gt; x) ∷ [])</code></h4>
<p>Similarly, when the user writes</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-symbol">((&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<ol style="list-style-type: decimal">
<li>the implicit <code>A</code> gets instantiated as a metavariable <code>_A</code></li>
<li>the type of the instantiated <code>listId</code> becomes <code>List _A -&gt; List _A</code></li>
<li><code>List _A</code> (what the instantiated <code>listId</code> expects as an argument) gets unified with <code>List (_B -&gt; _B)</code> (the type of the actual argument). <code>_B</code> is another metavariable. Recall that we don't know the type of <code>x</code> and hence we simply make it a meta</li>
<li><code>List _A</code> (this time the type of the result that <code>listId</code> returns) also gets unified with the expected type, which is <code>List (ℕ -&gt; ℕ)</code>, because <code>suc</code> prepended to the result of the <code>listId</code> application is of this type</li>
<li><p>we get the following <a href="https://en.wikipedia.org/wiki/Unification_(computer_science)#Unification_problem,_solution_set">unification problem</a> consisting of two equations:</p>
<pre><code> List _A =?= List (_B -&gt; _B)
 List _A =?= List (ℕ -&gt; ℕ)</code></pre></li>
<li><p>as before we can simplify the equations by stripping <code>List</code>s from both the sides of each of them:</p>
<pre><code> _A =?= _B -&gt; _B
 _A =?= ℕ -&gt; ℕ</code></pre></li>
<li><p>the second equation gives us <code>A := ℕ -&gt; ℕ</code> and it only remains to solve</p>
<pre><code> ℕ -&gt; ℕ =?= _B -&gt; _B</code></pre></li>
<li><p>which is easy: <code>_B := ℕ</code>. The full solution of the unification problem is</p>
<pre><code> _B := ℕ
 _A := ℕ -&gt; ℕ</code></pre></li>
</ol>
<h4 id="example-3-λ-xs---suc-listid-xs">Example 3: <code>λ xs -&gt; suc ∷ listId xs</code></h4>
<p>When the user writes</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-function">listId</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<ol style="list-style-type: decimal">
<li>the yet-unknown type of <code>xs</code> elaborates to a metavariable, say, <code>_LA</code></li>
<li>the implicit <code>A</code> of <code>listId</code> elaborates to a metavariable <code>_A</code></li>
<li><code>List _A</code> (what the instantiated <code>listId</code> expects as an argument) gets unified with <code>_LA</code> (the type of the actual argument)</li>
<li><code>List _A</code> (this time the type of the result that <code>listId</code> returns) also gets unified with the expected type, which is <code>ℕ -&gt; ℕ</code>, because <code>suc</code> prepended to the result of the <code>listId</code> application is of this type</li>
<li><p>we get a unification problem consisting of two equations:</p>
<pre><code> List _A =?= _LA
 List _A =?= List (ℕ -&gt; ℕ)</code></pre></li>
<li><code>_A</code> gets solved as <code>_A := ℕ -&gt; ℕ</code></li>
<li>and <code>_LA</code> gets solved as <code>_LA := List (ℕ -&gt; ℕ)</code></li>
<li><p>so the final solution is</p>
<pre><code> _A := ℕ -&gt; ℕ
 _LA := List (ℕ -&gt; ℕ)</code></pre></li>
</ol>
<p>But note that we could first resolve <code>_LA</code> as <code>List _A</code>, then resolve <code>_A</code> and then instantiate it in <code>List _A</code> (what <code>_LA</code> was resolved to), which would give us the same final solution.</p>
<p>In general, there are many possible routes that one can take when solving a unification problem, but some of them are less straightforward (and thus less efficient) than others. Such details are beyond the scope of this document, here we are only interested in unification problems that get generated during type checking and solutions to them. Arriving at those solutions is a pretty technical (and incredibly convoluted) thing.</p>
<h2 id="nicer-notation">Nicer notation</h2>
<p>In the previous section we were stripping <code>List</code> from both the sides of an equation. We were able to do this, because from the unification's point of view type constructors are injective (this has nothing to do with the <a href="https://github.com/agda/agda/blob/10d704839742c332dc85f1298b80068ce4db6693/test/Succeed/InjectiveTypeConstructors.agda"><code>--injective-type-constructors</code></a> pragma that <a href="https://lists.chalmers.se/pipermail/agda/2010/001526.html">makes Agda anti-classical</a>). I.e. <code>List A</code> uniquely determines <code>A</code>.</p>
<p>We'll denote &quot;<code>X</code> uniquely determines <code>Y</code>&quot; (the notation comes from the <a href="https://ncatlab.org/nlab/show/bidirectional+typechecking">bidirectional typechecking</a> discipline) as <code>X ⇉ Y</code>. So <code>List A ⇉ A</code>.</p>
<p>An explicitly provided argument (i.e. <code>x</code> in either <code>f x</code> or <code>f {x}</code>) uniquely determines the type of that argument. We'll denote that as <code>(x : A) ⇉ A</code>.</p>
<p>We'll denote &quot;<code>X</code> does not uniquely determine <code>Y</code>&quot; as <code>X !⇉ Y</code>.</p>
<p>We'll also abbreviate</p>
<pre><code>  X ⇉ Y₁
  X ⇉ Y₂
  ...
  X ⇉ yₙ</code></pre>
<p>as</p>
<pre><code>  X ⇉ Y₁ , Y₂ ... Yₙ</code></pre>
<p>(and similarly for <code>!⇉</code>).</p>
<p>We'll denote &quot;<code>X</code> can be determined in the current context&quot; by</p>
<pre><code>  ⇉ X</code></pre>
<p>Finally, we'll have derivation trees like</p>
<pre><code>  X        Y
  →→→→→→→→→→
    Z₁ , Z₂        A
    →→→→→→→→→→→→→→→→
           B</code></pre>
<p>which reads as &quot;if <code>X</code> and <code>Y</code> are determined in the current context, then it's possible to determine <code>Z₁</code> and <code>Z₂</code>, having which together with <code>A</code> determined in the current context, is enough to determine <code>B</code>&quot;.</p>
<h2 id="type-functions">Type functions</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">TypeFunctions</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span>
</pre>
<p>Analogously to <code>listId</code> we can define <code>fId</code> that works for any <code>F : Set -&gt; Set</code>, including <code>List</code>:</p>
<pre>  <span class="agda2-highlight-function">fId</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">fId</span> <span class="agda2-highlight-bound-variable">a</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">a</span>
</pre>
<p>Unfortunately applying <code>fId</code> to a list without explicitly instantiating <code>F</code> as <code>List</code></p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">fId</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>results in both <code>F</code> and <code>A</code> not being resolved. This might be surprising, but there is a good reason for this behavior: there are multiple ways <code>F</code> and <code>A</code> can be instantiated. Here's the solution that the user would probably have had in their mind:</p>
<pre><code>  _F := List
  _A := ℕ</code></pre>
<p>which is what a first-order unification engine would come up with. But Agda's unification engine is <a href="https://stackoverflow.com/a/2504347/3237465">higher-order</a> and so this solution is also valid:</p>
<pre><code>  _F := λ _ -&gt; List ℕ
  _A := Bool</code></pre>
<p>i.e. <code>F</code> ignores <code>A</code> and just returns <code>List ℕ</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">fId</span> <span class="agda2-highlight-symbol">{&#955;</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">_</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Given that there are two valid solutions, Agda does not pick one at random and instead reports that there's ambiguity.</p>
<p>Even if you specify <code>A = ℕ</code>, <code>F</code> still can be either <code>List</code> or <code>λ _ -&gt; List ℕ</code>, so you have to specify <code>F</code> (and then the problem reduces to the one that we considered earlier, hence there is no need to also specify <code>A</code>):</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">fId</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">List</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Therefore, <code>F A</code> (where <code>F</code> is a bound variable) uniquely determines neither <code>F</code> nor <code>A</code>, i.e. <code>F A !⇉ F , A</code>.</p>
<p><a href="https://github.com/andreasabel">Andreas Abel</a>'s commented:</p>
<blockquote>
<p>Future research could improve on unification via an analysis in which situation the chosen solution does not matter (however, I never got around to do this research).</p>
<p>The example you give is such an instance: it does not matter how we solve <code>_F _A =?= List ℕ</code>, because the solutions of <code>_F</code> and <code>_A</code> can never flow out of the expression <code>fId _F _A (1 ∷ 2 ∷ []) : _F _A</code>.</p>
</blockquote>
<h3 id="comparison-to-haskell-1">Comparison to Haskell</h3>
<p>A type application of a variable is injective in Haskell. I.e. unification of <code>f a</code> and <code>g b</code> (where <code>f</code> and <code>g</code> are type variables) forces unification of <code>a</code> and <code>b</code>, as well as unification of <code>f</code> and <code>g</code>. I.e. not only does <code>f a ⇉ a</code> hold for arbitrary type variable <code>f</code>, but also <code>f a ⇉ f</code>. This makes it possible to define functions like</p>
<pre><code>  fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>and use them without compulsively specifying <code>f</code> at the call site each time.</p>
<p>Haskell is able to infer <code>f</code>, because no analogue of Agda's <code>λ _ -&gt; List ℕ</code> is possible in Haskell as its surface language doesn't have type lambdas. You can't pass a type family as <code>f</code> either. Therefore there exists only one solution for &quot;unify <code>f a</code> with <code>List Int</code>&quot; in Haskell and it's the expected one:</p>
<pre><code>  f := List
  a := Int</code></pre>
<p>For a type family <code>F</code> we have <code>F a !⇉ a</code> (just like in Agda), unless <code>F</code> is an <a href="https://gitlab.haskell.org/ghc/ghc/wikis/injective-type-families">injective type family</a>.</p>
<h2 id="data-constructors">Data constructors</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">DataConstructors</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Data constructors are injective from the unification point of view and from the theoretical point of view as well (unlike type constructors). E.g. consider the type of vectors (a vector is a list whose length is statically known):</p>
<pre>  <span class="agda2-highlight-keyword">infixr</span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;&#7525;_</span></span>
  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>  <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-number">0</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;&#7525;_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>The <code>head</code> function is defined like that over <code>Vec</code>:</p>
<pre>  <span class="agda2-highlight-function">head&#7525;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">head&#7525;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>I.e. we require an input vector to have at least one element and return that first element.</p>
<p><code>n</code> can be left implicit, because <code>suc n ⇉ n</code>. In general, for a constructor <code>C</code> the following holds:</p>
<pre><code>  C x₁ x₂ ... xₙ ⇉ x₁ , x₂ ... xₙ</code></pre>
<p>A simple test:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">head&#7525;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Here we pass a one-element vector to <code>headᵥ</code> and Agda succesfully infers the implicit <code>n</code> of <code>headᵥ</code> to be <code>0</code> (i.e. no elements in the vector apart from the first one).</p>
<p>During unification the implicit <code>n</code> gets instantiated to a metavariable, say, <code>_n</code>, and <code>suc _n</code> (the expected length of the vector) gets unified with <code>suc zero</code> (i.e. 1, the actual length of the vector), which amounts to unifying <code>_n</code> with <code>zero</code>, which immediately results in <code>n := zero</code>.</p>
<p>Instead of having a constant vector, we can have a vector of an unspecified length and infer that length by providing <code>n</code> to <code>headᵥ</code> explicitly, as in</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">head&#7525;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>The type of that definition is <code>∀ {n} -&gt; Vec ℕ (suc n) -&gt; ℕ</code>.</p>
<p>We started by binding two variables without specifying their types, but those got inferred from how arguments are used by <code>headᵥ</code>.</p>
<p>Note that <code>_⇉_</code> is transitive, i.e. if <code>X ⇉ Y</code> and <code>Y ⇉ Z</code>, then <code>X ⇉ Z</code>. For example, since <code>Vec A n ⇉ n</code> (due to <code>Vec</code> being a type constructor) and <code>suc n ⇉ n</code> (due to <code>suc</code> being a data constructor), we have <code>Vec A (suc n) ⇉ n</code> (by transitivity of <code>_⇉_</code>).</p>
<h2 id="reduction">Reduction</h2>
<p>If <code>X</code> reduces to <code>Y</code> (we'll denote that as <code>X ~&gt; Y</code>) and <code>Y ⇉ Z</code>, then <code>X ⇉ Z</code>.</p>
<p>E.g. if we define an alternative version of <code>headᵥ</code> that uses <code>1 +_</code> instead of <code>suc</code>:</p>
<pre>  <span class="agda2-highlight-function">head&#7525;&#8314;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-function">head&#7525;&#8314;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>the <code>n</code> will still be inferrable:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">head&#7525;&#8314;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>This is because <code>1 + n</code> reduces to <code>suc n</code>, so the two definitions are equivalent.</p>
<p>Note however that a &quot;morally&quot; equivalent definition:</p>
<pre><code>  headᵥ⁺-wrong : ∀ {A n} -&gt; Vec A (n + 1) -&gt; A
  headᵥ⁺-wrong (x ∷ᵥ _) = x</code></pre>
<p>does not type check giving:</p>
<pre><code>  I&#39;m not sure if there should be a case for the constructor _∷ᵥ_,
  because I get stuck when trying to solve the following unification
  problems (inferred index ≟ expected index):
    suc n ≟ n₁ + 1
  when checking that the pattern x ∷ᵥ _ has type Vec A (n + 1)</code></pre>
<p>That's because <code>_+_</code> is defined by pattern matching on its left operand, so <code>1 + n</code> computes while <code>n + 1</code> is stuck and does not compute as <code>n</code> is a variable rather than an expression starting with a constructor of <code>ℕ</code>. <code>headᵥ⁺-wrong</code> is a contrived example, but this problem can arise in real cases, for example consider a naive attempt to define the <code>reverse</code> function over <code>Vec</code> using an accumulator, the helper type checks perfectly:</p>
<pre>  <span class="agda2-highlight-function">reverse-go</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">reverse-go</span> <span class="agda2-highlight-bound-variable">acc</span>  <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">acc</span>
  <span class="agda2-highlight-function">reverse-go</span> <span class="agda2-highlight-bound-variable">acc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-function">reverse-go</span> <span class="agda2-highlight-bound-variable">acc</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>but the final definition gives an error:</p>
<pre><code>  -- _n_390 + 0 != n of type ℕ
  reverse-wrong : ∀ {A n} -&gt; Vec A n -&gt; Vec A n
  reverse-wrong xs = reverse-go []ᵥ xs</code></pre>
<p>That's because <code>reverse-go</code> is appled to <code>[]ᵥ</code> of type <code>Vec A 0</code> and <code>xs</code> of type <code>Vec A n</code>, so it returns a <code>Vec A (n + 0)</code>, which is not definitionally the same thing as <code>Vec A n</code>. We could prove that <code>n + 0</code> equals <code>n</code> for any <code>n</code> and use that proof to rewrite <code>Vec A (n + 0)</code> into <code>Vec A n</code>, but that would make it harder to prove properties about <code>reverse</code> defined this way.</p>
<p>The usual way of approaching this problem is by generalizing the helper. In the case of <code>reverse</code> we can generalize the helper to the regular <code>foldl</code> function and define <code>reverse</code> in terms of that -- that's what <a href="https://github.com/agda/agda-stdlib/blob/7c8c17b407c14c5828b8755abb7584a4878286da/src/Data/Vec/Base.agda#L270-L271">they do</a> in the standard library. See <a href="https://stackoverflow.com/questions/33345899/how-to-enumerate-the-elements-of-a-list-by-fins-in-linear-time">this Stack Overflow question and answer</a> for a more complex and elaborated example. Anyway, end of digression.</p>
<p>Agda looks under lambdas when reducing an expression, so for example <code>λ n -&gt; 1 + n</code> and <code>λ n -&gt; suc n</code> are two definitionally equal terms:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>But Agda does not look under pattern matching lambdas, so for example these two functions</p>
<pre><code>  λ{ zero -&gt; zero; (suc n) -&gt; 1 + n }
  λ{ zero -&gt; zero; (suc n) -&gt; suc n }</code></pre>
<p>are not considered definitionally equal. In fact, even</p>
<pre><code>  _ : _≡_ {A = ℕ -&gt; ℕ}
      (λ{ zero -&gt; zero; (suc n) -&gt; suc n })
      (λ{ zero -&gt; zero; (suc n) -&gt; suc n })
  _ = refl</code></pre>
<p>is an error despite the two functions being syntactically equal. Here's the funny error:</p>
<pre><code>  (λ { zero → zero ; (suc n) → suc n }) x !=
  (λ { zero → zero ; (suc n) → suc n }) x of type ℕ
  when checking that the expression refl has type
  (λ { zero → zero ; (suc n) → suc n }) ≡
  (λ { zero → zero ; (suc n) → suc n })</code></pre>
<h2 id="pattern-matching">Pattern matching</h2>
<p>Generally speaking, pattern matching breaks inference. We'll consider various cases, but to start with the simplest ones we need to introduce a slightly weird definition of the plus operator:</p>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">WeirdPlus</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">DataConstructors</span>

  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_+&#8242;_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-inductive-constructor">zero</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span>
</pre>
<p>because the usual one</p>
<pre><code>  _+_ : ℕ -&gt; ℕ -&gt; ℕ
  zero  + m = m
  suc n + m = suc (n + m)</code></pre>
<p>is subject to certain unification heuristics, which the weird one doesn't trigger.</p>
<p>We'll be using the following function for demonstration purposes:</p>
<pre>  <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<h3 id="a-constant-argument">A constant argument</h3>
<p><code>idᵥ⁺</code> applied to a constant vector</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>gives us yellow, because Agda turns the implicit <code>n</code> and <code>m</code> into metavariables <code>_n</code> and <code>_m</code> and tries to unify the expected length of a vector (<code>_n +′ _m</code>) with the actual one (<code>2</code>) and there are multiple solutions to this problem, e.g.</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>n <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>n <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">2</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Howewer as per the previous the section, we do not really need to specify <code>m</code>, since <code>_+′_</code> is defined by recursion on <code>n</code> and hence for it to reduce it suffices to specify only <code>n</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>n <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>since with <code>n</code> specified this way the <code>_n</code> metavariable gets resolved as <code>_n := 1</code> and the expected length of an argument, <code>_n +′ _m</code>, becomes <code>suc m</code>, which Agda knows how to unify with <code>2</code> (the length of the actual argument).</p>
<p>Specifying <code>m</code> instead of <code>n</code> won't work though:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Agda can't resolve <code>_n</code>. This is because <code>_+′_</code> is defined by pattern matching on its first variable, so <code>1 +′ m</code> reduces to <code>suc m</code>, but <code>n +′ 1</code> is stuck and doesn't reduce to anything when <code>n</code> is a variable/metavariable/any stuck term. So even though there's a single solution to the</p>
<pre><code>  n +′ 1 =?= 2</code></pre>
<p>unification problem, Agda is not able to come up with it, because this would require unbounded search in the general case and Agda's unification machinery carefully avoids any such strategies.</p>
<h3 id="a-non-constant-argument">A non-constant argument</h3>
<p><code>idᵥ⁺</code> applied to a non-constant vector has essentially the same inference properties.</p>
<p>Without specializing the implicit arguments we get yellow:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-bound-variable">xs</span></span></span>
</pre>
<p>Specializing <code>m</code> doesn't help, still yellow:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-bound-variable">xs</span></span></span>
</pre>
<p>And specializing <code>n</code> (with or without <code>m</code>) allows Agda to resolve all the metas:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>n <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">xs</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>n <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<h3 id="examples">Examples</h3>
<p>So we have the following rule of thumb: whenever the type of function <code>h</code> mentions function <code>f</code> at the type level, every argument that gets pattern matched on in <code>f</code> (including any internal function calls) should be made explicit in <code>h</code> and every other argument can be left implicit (there are a few exceptions to this rule, which we'll consider below, but it applies in most cases).</p>
<h4 id="example-1-__">Example 1: <code>_+′_</code></h4>
<p><code>idᵥ⁺</code> mentions <code>_+′_</code> in its type:</p>
<pre><code>  idᵥ⁺ : ∀ {A n m} -&gt; Vec A (n +′ m) -&gt; Vec A (n +′ m)</code></pre>
<p>and <code>_+′_</code> pattern matches on <code>n</code>, hence Agda won't be able to infer <code>n</code>, i.e. the user will have to provide it and so it should be made explicit:</p>
<pre><code>  idᵥ⁺ : ∀ {A m} n -&gt; Vec A (n +′ m) -&gt; Vec A (n +′ m)</code></pre>
<p>Since <code>_+′_</code> doesn't match on its second argument, <code>m</code>, we leave it implicit.</p>
<h4 id="example-2-__">Example 2: <code>_∸_</code></h4>
<p>A function mentioning <code>_∸_</code></p>
<pre><code>  _-_ : ℕ -&gt; ℕ -&gt; ℕ
  n     - zero  = n
  zero  - suc m = zero
  suc n - suc m = n - m</code></pre>
<p>at type level has to receive both the arguments that get fed to <code>_∸_</code> explicitly as <code>_∸_</code> matches on both of them:</p>
<pre>  <span class="agda2-highlight-function">id&#7525;&#8315;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8760;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8760;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">id&#7525;&#8315;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>and none of</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8315;</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>  <span class="comment">-- `m` can't be inferred</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8315;</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>  <span class="comment">-- `n` can't be inferred</span>
</pre>
<p>is accepted unlike</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8315;</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<h4 id="example-3-__">Example 3: <code>_*_</code></h4>
<p>A function mentioning <code>_*_</code></p>
<pre><code>  _*_ : ℕ -&gt; ℕ -&gt; ℕ
  zero  * m = zero
  suc n * m = m + n * m</code></pre>
<p>at the type level has to receive both the arguments that get fed to <code>_*_</code> explicitly, even though <code>_*_</code> doesn't directly match on <code>m</code>. This is because in the second clause <code>_*_</code> expands to <code>_+_</code>, which does match on <code>m</code>. So it's</p>
<pre>  <span class="agda2-highlight-function">id&#7525;*</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">*</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">*</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">id&#7525;*</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>and none of</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;*</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>  <span class="comment">-- `m` can't be inferred</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;*</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">2</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">&#8759;&#7525;</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>  <span class="comment">-- `n` can't be inferred</span>
</pre>
<p>type check, unlike</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;*</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<h4 id="example-4-__-two-arguments">Example 4: <code>_+′_</code>, two arguments</h4>
<p>With this definition:</p>
<pre>  <span class="agda2-highlight-function">ignore2</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">ignore2</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
</pre>
<p>it suffices to explicitly provide either <code>n</code> or <code>m</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ignore2</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ignore2</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>This is because with explicitly provided <code>n</code> Agda can determine <code>m</code> from <code>n +′ m</code> and with explicitly provided <code>m</code> Agda can determine <code>n</code> from <code>m +′ n</code>.</p>
<h4 id="example-5-nested-__-two-arguments">Example 5: nested <code>_+′_</code>, two arguments</h4>
<p>In the following definition we have multiple mentions of <code>_+′_</code> at the type level:</p>
<pre>  <span class="agda2-highlight-function">ignore2p</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-bound-variable">p</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">p</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">ignore2p</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
</pre>
<p>and three variables used as arguments to <code>_+′_</code>, yet only the <code>n</code> variable needs to be bound explicitly. This is due to the fact that it's enough to know <code>n</code> to determine what <code>m</code> is (from <code>Vec ℕ (n +′ m)</code>) and then knowing both <code>n</code> and <code>m</code> is enough to determine what <code>p</code> is (from <code>Vec ℕ (n +′ (m +′ p))</code>). Which can be written as</p>
<pre><code>       n
       →
  n    m
  →→→→→→
     p</code></pre>
<p>Note that the order of the <code>Vec</code> arguments doesn't matter, Agda will postpone resolving a metavariable until there is enough info to resolve it.</p>
<p>A test:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ignore2p</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<h4 id="example-6-nested-__-one-argument">Example 6: nested <code>_+′_</code>, one argument</h4>
<p>A very similar example:</p>
<pre>  <span class="agda2-highlight-function">ignore1p</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-bound-variable">p</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">p</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">ignore1p</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
</pre>
<p>Just like in the previous case it's enough to provide only <code>n</code> explicitly as the same</p>
<pre><code>       n
       →
  n    m
  →→→→→→
     p</code></pre>
<p>logic applies. Test:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ignore1p</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-symbol">((</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<h4 id="large-elimination">Large elimination</h4>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">LargeElimination</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span>
</pre>
<p>So far we've been talking about functions that pattern match on terms and return terms, but in Agda we can also pattern match on terms and return types. Consider</p>
<pre>  <span class="agda2-highlight-function">ListOfBoolOr&#8469;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ListOfBoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-function">ListOfBoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-datatype">&#8469;</span>
</pre>
<p>This function matches on a <code>Bool</code> argument and returns <em>the type</em> of lists with the type of elements depending on the <code>Bool</code> argument.</p>
<p>Having an identity function over a <code>ListOfBoolOrℕ b</code></p>
<pre>  <span class="agda2-highlight-function">idListOfBoolOr&#8469;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ListOfBoolOr&#8469;</span> <span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ListOfBoolOr&#8469;</span> <span class="agda2-highlight-bound-variable">b</span>
  <span class="agda2-highlight-function">idListOfBoolOr&#8469;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>we can show that the implicit <code>b</code> can't be inferred, as this:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">idListOfBoolOr&#8469;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">3</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>results in unresolved metas, while this:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idListOfBoolOr&#8469;</span> <span class="agda2-highlight-symbol">{</span>b <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>is accepted by the type checker.</p>
<p>The reason for this behavior is the same as with all the previous examples: pattern matching blocks inference and <code>ListOfBoolOrℕ</code> is a pattern matching function.</p>
<h3 id="generalization">Generalization</h3>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">Generalization</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>In general: given a function <code>f</code> that receives <code>n</code> arguments on which there's pattern matching anywhere in the definition of <code>f</code> (including calls to other functions in the body of <code>f</code>) and <code>m</code> arguments on which there is no pattern matching, we have the following rule (for simplicity of presentation we place <code>pᵢ</code> before <code>xⱼ</code>, but the same rule works when they're interleaved)</p>
<pre><code>  p₁    ...    pₙ        (f p₁ ... pₙ x₁ ... xₘ)
  →→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→→
                x₁    ...    xₘ</code></pre>
<p>i.e. if every <code>pᵢ</code> can be inferred from the current context, then every <code>xⱼ</code> can be inferred from <code>f p₁ ... pₙ x₁ ... xₘ</code>.</p>
<p>There is an important exception from this rule and this is what comes next.</p>
<h3 id="constructor-headed-functions"><a href="https://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.FindingTheValuesOfImplicitArguments">Constructor-headed functions</a></h3>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">ConstructorHeadedFunctions</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">BasicsOfTypeInference</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">DataConstructors</span>
</pre>
<p>Consider a definition of <code>ListOfBoolOrℕ</code> that is slightly different from the previous one, but is isomorphic to it:</p>
<pre>  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span>

  <span class="agda2-highlight-function">ListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">BoolOr&#8469;</span> <span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Here <code>ListOfBoolOrℕ′</code> does not do any pattern matching itself and instead immediately returns <code>List (BoolOrℕ b)</code> with pattern matching performed in <code>BoolOrℕ b</code>. There's still pattern matching on <code>b</code> and the fact that it's inside another function call in the body of <code>ListOfBoolOrℕ′</code> should not change anything as we've discussed previously. Yet <code>id</code> defined over such lists:</p>
<pre>  <span class="agda2-highlight-function">idListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">b</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">b</span>
  <span class="agda2-highlight-function">idListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>does not require the user to provide <code>b</code> explicitly, i.e. the following type checks just fine:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idListOfBoolOr&#8469;&#8242;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>This works as follows: the expected type of an argument (<code>ListOfBoolOrℕ′ _b</code>) gets unified with the actual one (<code>List ℕ</code>):</p>
<pre><code>  ListOfBoolOrℕ′ _b =?= List ℕ</code></pre>
<p>after expanding <code>ListOfBoolOrℕ′</code> we get</p>
<pre><code>  List (BoolOrℕ _b) =?= List ℕ</code></pre>
<p>as usual <code>List</code> gets stripped from both the sides of the equation:</p>
<pre><code>  BoolOrℕ _b =?= ℕ</code></pre>
<p>and here Agda has a special rule, quoting the wiki:</p>
<blockquote>
<p>If all right hand sides of a function definition have distinct (type or value) constructor heads, we can deduce the shape of the arguments to the function by looking at the head of the expected result.</p>
</blockquote>
<p>In our case two &quot;constructor heads&quot; in the definition of <code>BoolOrℕ</code> are <code>Bool</code> and <code>ℕ</code>, which are distinct, and that makes Agda see that <code>BoolOrℕ</code> is injective, so unifying <code>BoolOrℕ _b</code> with <code>ℕ</code> amounts to finding the clause where <code>ℕ</code> is returted from <code>BoolOrℕ</code>, which is</p>
<pre><code>  BoolOrℕ true  = ℕ</code></pre>
<p>and this determines that for the result to be <code>ℕ</code> the value of <code>_b</code> must be <code>true</code>, so the unification problem gets solved as</p>
<pre><code>  _b := true</code></pre>
<p><code>BoolOrℕ</code> differs from</p>
<pre><code>  ListOfBoolOrℕ : Bool -&gt; Set
  ListOfBoolOrℕ false = List Bool
  ListOfBoolOrℕ true  = List ℕ</code></pre>
<p>in that the latter definition has the same head in both the clauses (<code>List</code>) and so the heuristic doesn't apply. Even though Agda really could have figured out that <code>ListOfBoolOrℕ</code> is also injective (the fact that <code>ListOfBoolOrℕ</code> is not consdered invertible is more of an implementation detail than a theoretical limination).</p>
<p>Here's an example of a theoretical limitation: a definition like</p>
<pre>  <span class="agda2-highlight-function">BoolOrBool</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">BoolOrBool</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-function">BoolOrBool</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
</pre>
<p>can't be inverted, because the result (<code>Bool</code> in both the cases) does not determine the argument (either <code>true</code> or <code>false</code>).</p>
<h4 id="example-1-universe-of-types">Example 1: universe of types</h4>
<p>There's a standard technique (<a href="https://groups.google.com/forum/#!msg/idris-lang/N9_pVqG8dO8/mHlNmyL6AwAJ">the universe pattern</a>) that allows us to get ad hoc polymorphism (a.k.a. type classes) for a closed set of types in a dependently typed world.</p>
<p>We introduce a universe of types, which is a data type containing tags for actual types:</p>
<pre>  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">Uni</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-inductive-constructor">bool</span> <span class="agda2-highlight-inductive-constructor">nat</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Uni</span>
    <span class="agda2-highlight-inductive-constructor">list</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Uni</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Uni</span>
</pre>
<p>interpret those tags as types that they encode:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;_&#10215;</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Uni</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-inductive-constructor">bool</span>   <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-inductive-constructor">nat</span>    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-inductive-constructor">list</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span>
</pre>
<p>and then mimic the <code>Eq</code> type class for the types from this universe by directly defining equality functions:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==Bool_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==Bool</span></span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==Bool</span></span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span><span class="agda2-highlight-catchall-clause">     </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-catchall-clause">==Bool</span></span></span><span class="agda2-highlight-catchall-clause"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span>     <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">false</span>

  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==&#8469;_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
  <span class="agda2-highlight-inductive-constructor">zero</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==&#8469;</span></span> <span class="agda2-highlight-inductive-constructor">zero</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==&#8469;</span></span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==&#8469;</span></span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span><span class="agda2-highlight-catchall-clause">     </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-catchall-clause">==&#8469;</span></span></span><span class="agda2-highlight-catchall-clause"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span>     <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">false</span>

  <span class="agda2-highlight-keyword">mutual</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==List_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
    <span class="agda2-highlight-inductive-constructor">[]</span>       <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==List</span></span> <span class="agda2-highlight-inductive-constructor">[]</span>       <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">true</span>
    <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==List</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-bound-variable">ys</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==</span></span> <span class="agda2-highlight-bound-variable">y</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&amp;&amp;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==List</span></span> <span class="agda2-highlight-bound-variable">ys</span><span class="agda2-highlight-symbol">)</span>
    <span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span><span class="agda2-highlight-catchall-clause">        </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-catchall-clause">==List</span></span></span><span class="agda2-highlight-catchall-clause"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span>        <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">false</span>

    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10214;</span></span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#10215;</span></span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Bool</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==_</span></span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">nat</span>   <span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==&#8469;</span></span>    <span class="agda2-highlight-bound-variable">y</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==_</span></span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">bool</span>  <span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==Bool</span></span> <span class="agda2-highlight-bound-variable">y</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_==_</span></span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">list</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==List</span></span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p><code>_==_</code> checks equality of two elements from any type from the universe.</p>
<p>Note that <code>_==List_</code> is defined mutually with <code>_==_</code>, because elements of lists can be of any type from the universe, i.e. they can also be lists, hence the mutual recursion.</p>
<p>A few tests:</p>
<pre>  <span class="comment">-- Check equality of two equal elements of `&#8469;`.</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">42</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==</span></span> <span class="agda2-highlight-number">42</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="comment">-- Check equality of two non-equal elements of `List Bool`.</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">((</span><span class="agda2-highlight-inductive-constructor">true</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">false</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="comment">-- Check equality of two equal elements of `List (List &#8469;)`.</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(((</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">81</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">57</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==</span></span> <span class="agda2-highlight-symbol">((</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">81</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">57</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">true</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="comment">-- Check equality of two non-equal elements of `List (List &#8469;)`.</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(((</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">81</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">57</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">==</span></span> <span class="agda2-highlight-symbol">((</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">81</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">false</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>It's possible to leave <code>A</code> implicit in <code>_==_</code> and get it inferred in the tests above precisely because <code>⟦_⟧</code> is constructor-headed. If we had <code>bool₁</code> and <code>bool₂</code> tags both mapping to <code>Bool</code>, inference for <code>_==_</code> would not work for booleans, lists of booleans etc. In the version of Agda I'm using inference for naturals, lists of naturals etc still works though, if an additional <code>bool</code> is added to the universe, i.e. breaking constructor-headedness of a function for certain arguments does not result in inference being broken for others.</p>
<h4 id="example-2-booltoℕ">Example 2: <code>boolToℕ</code></h4>
<p>Constructor-headed functions can also return values rather than types. For example this function:</p>
<pre>  <span class="agda2-highlight-function">boolTo&#8469;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">boolTo&#8469;</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">zero</span>
  <span class="agda2-highlight-function">boolTo&#8469;</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-inductive-constructor">zero</span>
</pre>
<p>is constructor-headed, because in the two clauses heads are constructors and they're different (<code>zero</code> vs <code>suc</code>).</p>
<p>So if we define a version of <code>id</code> that takes a <code>Vec</code> with either 0 or 1 element:</p>
<pre>  <span class="agda2-highlight-function">idVecAsMaybe</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">boolTo&#8469;</span> <span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">boolTo&#8469;</span> <span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">idVecAsMaybe</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>then it won't be necessary to specify <code>b</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idVecAsMaybe</span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idVecAsMaybe</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>as Agda knows how to solve <code>boolToℕ _b =?= zero</code> or <code>boolToℕ _b =?= suc zero</code> due to <code>boolToℕ</code> being invertible.</p>
<p><code>idVecAsMaybe</code> supplied with a vector of length greater than <code>1</code> correctly gives an error (as opposed to merely reporting that there's an unsolved meta):</p>
<pre><code>  -- suc _n_624 != zero of type ℕ
  _ = idVecAsMaybe (0 ∷ᵥ 1 ∷ᵥ []ᵥ)</code></pre>
<p>Note that <code>boolToℕ</code> defined like that:</p>
<pre>  <span class="agda2-highlight-function">boolTo&#8469;&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Bool</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">boolTo&#8469;&#8242;</span> <span class="agda2-highlight-inductive-constructor">false</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">zero</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-inductive-constructor">zero</span>
  <span class="agda2-highlight-function">boolTo&#8469;&#8242;</span> <span class="agda2-highlight-inductive-constructor">true</span>  <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-inductive-constructor">zero</span>
</pre>
<p>is not considered to be constructor-headed, because Agda does not attempt to unfold recursive definitions in the RHS of a clause of a function. With this definition the second test in</p>
<pre>  <span class="agda2-highlight-function">idVecAsMaybe&#8242;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">boolTo&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">boolTo&#8469;&#8242;</span> <span class="agda2-highlight-bound-variable">b</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">idVecAsMaybe&#8242;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idVecAsMaybe&#8242;</span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">idVecAsMaybe&#8242;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">0</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>is yellow. But not the first one. I guess with <code>idVecAsMaybe′ []ᵥ</code> Agda tries to unify <code>zero</code> (the actual length of the vector) with both the RHSes of <code>boolToℕ′</code> and since <code>zero</code> is definitely not equal to <code>suc zero</code>, only the <code>zero + zero</code> case remains, so Agda finally decides to reduce that expression to find out that it indeed equals to <code>zero</code>.</p>
<h3 id="constructorargument-headed-functions">Constructor/argument-headed functions</h3>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">ConstructorArgumentHeadedFunctions</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">DataConstructors</span>
</pre>
<p>Recall that we've been using a weird definition of plus</p>
<blockquote>
<p>because the usual one</p>
<pre><code>  _+_ : ℕ -&gt; ℕ -&gt; ℕ
  zero  + m = m
  suc n + m = suc (n + m)</code></pre>
<p>is subject to certain unification heuristics, which the weird one doesn't trigger.</p>
</blockquote>
<p>As you can see in the usual definition we return one of the arguments in the first clause and the second clause starts with a constructor. Just like for regular constructor-headed functions, Agda has enhanced inference for functions of this kind as well.</p>
<p>Quoting the <a href="https://github.com/agda/agda/blob/064095e14042bdf64c7d7c97c2869f63f5f1f8f6/doc/release-notes/2.5.4.md#pattern-matching">changelog</a>:</p>
<blockquote>
<p>Improved constraint solving for pattern matching functions Constraint solving for functions where each right-hand side has a distinct rigid head has been extended to also cover the case where some clauses return an argument of the function. A typical example is append on lists:</p>
<pre><code>  _++_ : {A : Set} → List A → List A → List A
  []       ++ ys = ys
  (x ∷ xs) ++ ys = x ∷ (xs ++ ys)</code></pre>
<p>Agda can now solve constraints like <code>?X ++ ys == 1 ∷ ys</code> when <code>ys</code> is a neutral term.</p>
</blockquote>
<h4 id="example-1-back-to-idᵥ">Example 1: back to <code>idᵥ⁺</code></h4>
<p>Now if we come back to this example:</p>
<blockquote>
<p>
<code>idᵥ⁺</code> applied to a non-constant vector has essentially the same inference properties.
</p>
<p>
Without specializing the implicit arguments we get yellow:
</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-bound-variable">xs</span></span></span>
</pre>
<p>
Specializing <code>m</code> doesn't help, still yellow:
</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">+&#8242;</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-bound-variable">xs</span></span></span>
</pre>
</blockquote>
<p>but define <code>idᵥ⁺</code> over <code>_+_</code> rather than <code>_+′_</code>:</p>
<pre>  <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>then supplying only <code>m</code> explicitly:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">xs</span>
</pre>
<p>satisfies the type checker due to <code>_+_</code> being constructor/argument-headed.</p>
<p>And</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-bound-variable">xs</span></span></span>
</pre>
<p>still gives yellow, because it's still inherently ambiguous.</p>
<p>Additionally, this now also type checks:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">id&#7525;&#8314;</span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>This is because instantiating <code>m</code> at <code>0</code> in <code>idᵥ⁺</code> makes <code>_+_</code> constructor-headed, because if we inline <code>m</code> in the definition of <code>_+_</code>, we'll get:</p>
<pre><code>  _+0 : ℕ -&gt; ℕ
  zero  +0 = zero
  suc n +0 = suc (n +0)</code></pre>
<p>which is clearly constructor-headed.</p>
<p>And</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">id&#7525;&#8314;</span></span> <span class="agda2-highlight-symbol">{</span>m <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">1</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-number">2</span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">&#8759;&#7525;</span></span></span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"> </span></span><span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">[]&#7525;</span></span></span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>still does not type check, because inlining <code>m</code> as <code>1</code> does not make <code>_+_</code> constructor-headed:</p>
<pre><code>  _+1 : ℕ -&gt; ℕ
  zero  +1 = suc zero
  suc n +1 = suc (n +1)</code></pre>
<p>-- #### Example 2: polyvariadic <code>zipWith</code>: list-based</p>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">PolyvariadicZipWith</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.List.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">List</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Vec.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">Vec</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;&#7525;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">[]</span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>We can define this family of functions over vectors:</p>
<pre><code>  replicate : ∀ {m} → A → Vec A m
  map : ∀ {m} → (A → B) → Vec A m → Vec B m
  zipWith : ∀ {m} → (A → B → C) → Vec A m → Vec B m → Vec C m
  zipWith3 : ∀ {m} → (A → B → C → D) → Vec A m → Vec B m → Vec C m → Vec D m</code></pre>
<p>(the Agda stdlib provides all of those but the last one)</p>
<p>Can we define a generic function that covers all of the above? Its type signature should look like this:</p>
<pre><code>  (A₁ -&gt; A₂ -&gt; ... -&gt; B) -&gt; Vec A₁ m -&gt; Vec A₂ m -&gt; ... -&gt; Vec B m</code></pre>
<p>Yes: we can parameterize a function by a list of types and compute those n-ary types from the list. Folding a list of types into a type, given also the type of the result, is trivial:</p>
<pre>  <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ToFun</span>  <span class="agda2-highlight-inductive-constructor">[]</span>      <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>
</pre>
<p>This allows us to compute the n-ary type of the function. In order to compute the n-ary type of the result we need to map the list of types with <code>λ A -&gt; Vec A m</code> and turn <code>B</code> (the type of the resulting of the zipping function) into <code>Vec B m</code> (the type of the final result):</p>
<pre>  <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">List.map</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>It only remains to recurse on the list of types in an auxiliary function (n-ary <code>(&lt;*&gt;)</code>, in Haskell jargon) and define <code>zipWithN</code> in terms of that function (we use <code>Vec.zipWith _$_</code> instead of <code>_⊛_</code>, because the latter has a <a href="https://github.com/agda/agda-stdlib/issues/1338">slightly broken inference</a> in some versions of the standard library):</p>
<pre>  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">}</span>     <span class="agda2-highlight-bound-variable">ys</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">ys</span>
  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">fs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">Vec.zipWith</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_$_</span></span> <span class="agda2-highlight-bound-variable">fs</span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span>

  <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">Vec.replicate</span> <span class="agda2-highlight-bound-variable">f</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Some tests verifying that the function does what it's supposed to:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Note how we do not provide the list of types explicitly in any of these cases, even though there's pattern matching on that list.</p>
<p>Your first guess is probably that Agda can infer the list of types from the type of the function passed to <code>zipWithN</code>. I.e. the type of <code>_+_</code> is <code>ℕ -&gt; ℕ -&gt; ℕ</code> and so it corresponds to <code>Fun (ℕ ∷ ℕ ∷ []) ℕ</code>. But that is not really clear to Agda as this snippet:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">refl</span></span></span>
</pre>
<p>gives yellow. And this is for a good reason, there are three ways to compute <code>ℕ -&gt; ℕ -&gt; ℕ</code> with <code>ToFun</code>:</p>
<pre><code>  ToFun (ℕ ∷ ℕ ∷ [])  ℕ             -- The obvious one.
  ToFun (ℕ ∷ [])     (ℕ -&gt; ℕ)       -- A sneaky one.
  ToFun []           (ℕ -&gt; ℕ -&gt; ℕ)  -- Another sneaky one.</code></pre>
<p>So the <code>ToFun _As _B =?= ℕ -&gt; ℕ -&gt; ℕ</code> unification problem does not have a single solution and hence can't be solved by Agda.</p>
<p>However Agda sees that <code>zipWithN _+_</code> is applied to two vectors and the result is also a vector and since in the type signature of <code>zipWithN</code></p>
<pre><code>  zipWithN : ∀ {As B n} -&gt; ToFun As B -&gt; ToVecFun As B n</code></pre>
<p>the types of the arguments and the result are computed from <code>ToVecFun As B n</code>, we have the following unification problem:</p>
<pre><code>  ToVecFun _As _B _n =?= Vec ℕ m -&gt; Vec ℕ m -&gt; Vec ℕ m</code></pre>
<p>which Agda can immediately solve as</p>
<pre><code>  _As := ℕ ∷ ℕ ∷ []
  _B  := ℕ
  _n  := m</code></pre>
<p>And indeed there's no yellow here:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>The reason for that is that <code>ToVecFun</code> does not return an arbitrary <code>B</code> in the <code>[]</code> case like <code>ToFun</code> -- <code>ToVecFun</code> always returns a <code>Vec</code> in the <code>[]</code> case, so resolving metas as</p>
<pre><code>  _As := ℕ ∷ []
  _B  := ℕ -&gt; ℕ
  _n  := m</code></pre>
<p>is not possible as that would compute to <code>Vec ℕ m -&gt; Vec (ℕ -&gt; ℕ) m</code> rather than <code>Vec ℕ m -&gt; Vec ℕ m -&gt; Vec ℕ m</code>.</p>
<p>Hence there's no ambiguity now and since <code>ToVecFun</code> also returns a <code>_-&gt;_</code> in the <code>_∷_</code> case, that function is constructor-headed (as <code>Vec</code> and <code>_-&gt;_</code> are two different type constructors) and Agda knows how to infer the list of types.</p>
<p>If we omit the resulting vector, we'll get yellow:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">zipWithN</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-primitive"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">_+_</span></span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">(</span></span><span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">1</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">&#8759;&#7525;</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">2</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">&#8759;&#7525;</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">3</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">&#8759;&#7525;</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-unsolved-meta">[]&#7525;</span></span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>as a standlone</p>
<pre><code>  ToVecFun _As _B _n =?= Vec ℕ m -&gt; Vec ℕ m -&gt; _R</code></pre>
<p>is inherently ambiguous again and Agda would need to do some non-trivial proof search in order to realize that <code>_R</code> can't be an <code>_-&gt;_</code> because of what the other equation is:</p>
<pre><code>  ToFun _As _B =?= ℕ -&gt; ℕ -&gt; ℕ</code></pre>
<p>However, by specifying <code>B</code> to something that is clearly different from <code>-&gt;</code>, we can turn <code>ToFun</code> (a constructor/argument-headed function) into a proper constructor-headed function. This type checks:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>And hence we can omit the resulting vector, if <code>B</code> is specified, because knowing <code>B</code> and the type of the zipping function is sufficient for inverting <code>ToFun</code> and inferring <code>As</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">{</span>B <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>We don't need to invert <code>ToFun</code> when the <em>spine</em> of <code>As</code> is provided explicitly:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">{</span>As <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>as Agda only needs to know the spine of <code>As</code> and not the actual types stored in the list in order for <code>ToFun</code> to compute (since <code>ToFun</code> is defined by pattern matching on the spine of its argument and so the actual elements of the list are computationally irrelevant). <code>ToFun (_A₁ ∷ _A₂ ∷ []) _B</code> computes to <code>_A₁ -&gt; _A₂ -&gt; _B</code> and unifying that type with <code>ℕ -&gt; ℕ -&gt; ℕ</code> is a trivial task.</p>
<p>Omitting a second vector still allows Agda to infer everything:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>as it only needs to solve</p>
<pre><code>  ToVecFun _As _B _n =?= Vec ℕ m -&gt; _ -&gt; Vec ℕ m</code></pre>
<p>as</p>
<pre><code>  _As := Vec ℕ m ∷ Vec ℕ m ∷ []
  _B  := Vec ℕ m
  _n  := m</code></pre>
<p>(which is possible due to the type of result being the concrete <code>Vec</code>, disjoint with <code>_-&gt;_</code>) and then solve all the pointwise equations:</p>
<pre><code>  1 + _ =?= 5
  2 + _ =?= 6
  3 + _ =?= 7</code></pre>
<p>by reducing them to</p>
<pre><code>  suc _             =?= suc (suc (suc (suc (suc _))))
  suc (suc _)       =?= suc (suc (suc (suc (suc (suc _)))))
  suc (suc (suc _)) =?= suc (suc (suc (suc (suc (suc (suc _))))))</code></pre>
<p>(due to <code>_+_</code> being defined by pattern matching on its first argument) and then inverting all the <code>suc</code>s.</p>
<p>Omitting a first vector gives yellow, though:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">refl</span></span></span>
</pre>
<p>as the version of Agda that I'm using can't solve equations like</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol"><span class="agda2-highlight-unsolved-meta">_</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">+</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-number">5</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-unsolved-constraint"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-inductive-constructor">refl</span></span></span>
</pre>
<p>due <code>_ + 4</code> being stuck and not reducing to anything. Even though Agda could potentially solve such equations, given the constructor/variable-headedness of <code>_+_</code>.</p>
<p>Finally, constructor-headedness is compositional. The</p>
<pre><code>  ToVecFun _As _B _n =?= Vec ℕ m -&gt; Vec ℕ m -&gt; Vec ℕ m</code></pre>
<p>problem expands to</p>
<pre><code>  ToFun (List.map (λ A -&gt; Vec A m) _As) (Vec _B _n) =?= Vec ℕ m -&gt; Vec ℕ m -&gt; Vec ℕ m</code></pre>
<p>Agda sees that the RHS was computed from the <code>_∷_</code> case of <code>ToFun</code>, but the actual argument of <code>ToFun</code> is not a meta or a <code>_∷_</code> already, it's a <code>List.map (λ A -&gt; Vec A m) _As</code> and so Agda needs to invert <code>List.map</code> for unification to proceed. Which is no problem, since <code>List.map</code> is also constructor-headed.</p>
<h2 id="eta-rules">Eta-rules</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">EtaRules</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>Agda implements eta-rules for <a href="https://ncatlab.org/nlab/show/negative+type">negative types</a>.</p>
<p>One such rule is that a function is definitionally equal to its eta-expanded version:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-bound-variable">x</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Usefulness of this eta-rule is not something that one thinks of much, but that is only until they try to work in a language that doesn't support the rule (spoiler: it's a huge pain).</p>
<p>All records support eta-rules by default (that can be switched off for a single record via an explicit <a href="https://agda.readthedocs.io/en/latest/language/record-types.html#eta-expansion"><code>no-eta-equality</code></a> mark or for all records in a file via <code>{-# OPTIONS --no-eta-equality #-}</code> at the beginning of the file).</p>
<p>The simplest record is one with no fields:</p>
<pre>  <span class="agda2-highlight-keyword">record</span> <span class="agda2-highlight-record">Unit</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-keyword">constructor</span> <span class="agda2-highlight-inductive-constructor">unit</span>
</pre>
<p>The eta-rule for <code>Unit</code> is &quot;all terms of type <code>Unit</code> are <em>definitionally</em> equal to <code>unit</code>&quot;:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">u</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Unit</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">u</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">unit</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">u</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Consequently, since all terms of type <code>Unit</code> are equal to <code>unit</code>, they are also equal to each other:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">u1</span> <span class="agda2-highlight-bound-variable">u2</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Unit</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">u1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">u2</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">u1</span> <span class="agda2-highlight-bound-variable">u2</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Since Agda knows that any value of type <code>Unit</code> is in fact <code>unit</code>, Agda can infer the value of any implicit argument of type <code>Unit</code>. I.e. <code>A</code> and <code>{_ : Unit} -&gt; A</code> are isomorphic for any <code>A</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Unit</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">({</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Unit</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">A</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>This eta-rule applies to <code>⊤</code> as well, precisely because <code>⊤</code> is defined as a record with no fields.</p>
<p>For a record with fields the eta-rule is &quot;an element of the record is always the constructor of the record applied to its fields&quot;. For example:</p>
<pre>  <span class="agda2-highlight-keyword">record</span> <span class="agda2-highlight-record">Triple</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-keyword">constructor</span> <span class="agda2-highlight-inductive-constructor">triple</span>
    <span class="agda2-highlight-keyword">field</span>
      <span class="agda2-highlight-field">fst</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span>
      <span class="agda2-highlight-field">snd</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">B</span>
      <span class="agda2-highlight-field">thd</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">C</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">Triple</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">t</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Triple</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">t</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">triple</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-field">fst</span> <span class="agda2-highlight-bound-variable">t</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-field">snd</span> <span class="agda2-highlight-bound-variable">t</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-field">thd</span> <span class="agda2-highlight-bound-variable">t</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">t</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Correspondingly, since Agda knows that any value of type <code>Triple A B C</code> is <code>triple</code> applied to some argument, these two types are isomorphic:</p>
<pre><code>  ∀ {x y z} -&gt; D x y z
  {(triple x y z) : Triple A B C} -&gt; D x y z</code></pre>
<p>for any <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> as witnessed by</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">C</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">({</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">(</span></span><span class="agda2-highlight-bound-variable">triple</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">)</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Triple</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">d</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">d</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">C</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">(</span></span><span class="agda2-highlight-bound-variable">triple</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span><span class="agda2-highlight-symbol"><span class="agda2-highlight-bound-variable">)</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-record">Triple</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">C</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">D</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-bound-variable">z</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">d</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">d</span>
</pre>
<p>We'll consider the opportunities that this feature gives us a bit later.</p>
<p>Supporting eta-equality for sum types is <a href="https://ncatlab.org/nlab/show/sum+type#as_a_positive_type">possible in theory</a>, but Agda does not implement that. Any <code>data</code> definition in Agda does not support eta-equality, including an empty <code>data</code> declaration like</p>
<pre>  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">Empty</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>(which is always isomorphic to <code>Data.Empty.⊥</code> and is how <code>⊥</code> is defined in the first place).</p>
<p>Eta-rules for records may seem not too exciting, but there are a few important use cases.</p>
<h3 id="computing-predicates-division">Computing predicates: division</h3>
<p>Consider the division function (defined by repeated subtraction in a slightly weird way to please the termination checker):</p>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">Div-v1</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.List.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">List</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Maybe.Base</span>

  <span class="comment">-- This function divides its first argument by the successor of the second one via repeated</span>
  <span class="comment">-- subtraction.</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div-suc`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-suc`</span></span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">go</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-function">go</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
    <span class="agda2-highlight-function">go</span>  <span class="agda2-highlight-number">0</span>       <span class="agda2-highlight-bound-variable">m</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
    <span class="agda2-highlight-function">go</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span>  <span class="agda2-highlight-number">0</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">go</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
    <span class="agda2-highlight-function">go</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">go</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span>

  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Maybe</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-number">0</span>     <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">nothing</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">just</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-suc`</span></span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>An attempt to divide a natural number by <code>0</code> results in <code>nothing</code>, otherwise we get the quotient wrapped in <code>just</code>.</p>
<p>We can check that all natural numbers up to <code>12</code> get divided by <code>3</code> correctly:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">List.map</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-number">3</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">8</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">10</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">11</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">12</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-function">List.map</span>  <span class="agda2-highlight-inductive-constructor">just</span>              <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">4</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>and that an attempt to divide any number by <code>0</code> will give us <code>nothing</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-inductive-constructor">nothing</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>This all works as expected, however we can redefine the division function is a way that allows us to</p>
<ol style="list-style-type: decimal">
<li>not wrap the result in <code>Maybe</code></li>
<li>easily recover the original definition</li>
</ol>
<p>Here's how:</p>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">Div-v2</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-module">Div-v1</span> <span class="agda2-highlight-keyword">using</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div-suc`_</span></span><span class="agda2-highlight-symbol">)</span>

  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.List.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">List</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Maybe.Base</span>

  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8802;0</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8802;0</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8869;</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-catchall-clause">_&#8802;0</span></span></span><span class="agda2-highlight-catchall-clause"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-catchall-clause">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-record">&#8868;</span>

  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8802;0</span></span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div`_</span></span> <span class="agda2-highlight-bound-variable">n</span>  <span class="agda2-highlight-number">0</span>      <span class="agda2-highlight-symbol">{()}</span>
  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div`_</span></span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-suc`</span></span> <span class="agda2-highlight-bound-variable">m</span>  <span class="comment">-- The worker is the same as in the original version.</span>
</pre>
<p>Now instead of returning a <code>Maybe</code> we require the caller to provide a proof that the divisor is not zero. And the original definition can be recovered as</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div-original`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Maybe</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-original`</span></span> <span class="agda2-highlight-number">0</span>     <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">nothing</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-original`</span></span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">just</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>There exist a bunch of blogposts advocating a similar style of programming:</p>
<ol style="list-style-type: decimal">
<li><a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don't validate</a></li>
<li><a href="https://www.parsonsmatt.org/2017/10/11/type_safety_back_and_forth.html">Type Safety Back and Forth</a></li>
<li><a href="http://www.haskellforall.com/2020/07/the-golden-rule-of-software-quality.html">The golden rule of software quality</a></li>
</ol>
<p>However all those blogposts talk about introducing separate data types for expressing invariants, while what we do here instead is use the regular type of natural numbers and add an additional type-level predicate computing to <code>⊥</code> (a type, for which no value can be provided), if the divisor is zero, and <code>⊤</code> (a type with a single value) otherwise. I.e. the only way to provide a value of type <code>m ≢0</code> is to make this predicate compute to <code>⊤</code>, which requires <code>m</code> to be a <code>suc</code> of some natural number.</p>
<p>What Agda makes nice is that we don't need to ask the caller to provide a proof explicitly when <code>m</code> is in <a href="https://wiki.haskell.org/Weak_head_normal_form">WHNF</a> (i.e. <code>m</code> is either <code>zero</code> or <code>suc m'</code> for some <code>m'</code>, definitionally), which enables us to leave the <code>m ≢0</code> argument implicit. The reason for that is when the outermost constructor of <code>m</code> is known, we have two cases:</p>
<ol style="list-style-type: decimal">
<li>it's <code>zero</code>: <code>zero ≢0</code> reduces to <code>⊥</code> and no value of that type can be provided, hence there's no point in making that argument explicit as the user will have to reconsider what they're doing anyway</li>
<li>it's <code>suc</code>: <code>suc m' ≢0</code> reduces to <code>⊤</code> and due to the eta-rule of <code>⊤</code>, the value of <code>⊤</code> can be inferred automatically</li>
</ol>
<p>Let us now see how this works in practice. Here we divide all numbers up to <code>12</code> by <code>4</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">List.map</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-number">4</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">8</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">10</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">11</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">12</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span>                             <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>Note how we don't need to provide any proof that the divisor is not equal to zero, Agda figures that out itself.</p>
<p>An attempt to divide a number by <code>0</code> gives us an unresolved metavariable of type <code>⊥</code> (note the yellow):</p>
<pre>  <span class="comment">-- _1254 : &#8869;</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">`div`</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">0</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div`</span></span> <span class="agda2-highlight-number">0</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>(if you're curious whether it's possible to throw an actual error instead of having an unresolved metavariable, then Agda does allow us to do that via <a href="https://agda.readthedocs.io/en/latest/language/reflection.html">Reflection</a>, see <a href="https://github.com/effectfully/random-stuff/blob/0857360c917a834a0473ab68fcf24c05960fc335/ThrowOnZero.agda">this file</a>)</p>
<p>So in short, the eta-rule of <code>⊤</code> allows for convenient APIs when there are computational properties involved and it's fine to force upon the caller to specify enough info to make the property compute. In the above cases we only required a single argument to be in WHNF, but in other cases it can be necessary to have multiple arguments in <a href="https://ncatlab.org/nlab/show/canonical+form">canonical form</a> (see <a href="https://stackoverflow.com/questions/33270639/so-whats-the-point">this Stackoverflow question and answer</a> for an example).</p>
<p>If we attempt to call <code>_`div`_</code> with the divisor argument not being in WHNF, we'll get yellow:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8802;0</span></span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">n</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">`div`</span></span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-unsolved-meta">m</span></span>
</pre>
<p>since it's not possible to infer the value of type <code>m ≢0</code> when the type is stuck and can't reduce to anything. Which is rather inconvenient as we now have to explicitly thread the divisor-not-equal-to-zero proof through every function that eventually defers to <code>_`div`_</code>. See the next section for an alternative solution.</p>
<h3 id="bonus-singletons">Bonus: singletons</h3>
<p>Instead of checking if a value satisfies a certain predicate, we can sometimes provide that value in a <a href="http://wiki.c2.com/?CorrectByConstruction">correct by construction</a> manner. In the case of division we need to ensure that the divisor is not zero, so we could have a special type of non-zero natural numbers for that:</p>
<pre>  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">&#8469;&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-inductive-constructor">suc&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;&#8321;</span>
</pre>
<p>and define:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div&#8321;`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;&#8321;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div&#8321;`</span></span> <span class="agda2-highlight-inductive-constructor">suc&#8321;</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-suc`</span></span> <span class="agda2-highlight-bound-variable">m</span>
</pre>
<p>This is essentially what the &quot;Parse, don't validate&quot; approach referenced earlier is about.</p>
<p>However in a dependently typed language we don't actually need to create a bespoke data type for the purpose of ensuring that a value is an application of a certain constructor. Instead we can define a singleton type that allows us to promote any value to the type level:</p>
<pre>  <span class="agda2-highlight-keyword">data</span> <span class="agda2-highlight-datatype">Promote</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">x</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Promote</span> <span class="agda2-highlight-bound-variable">x</span>
</pre>
<p>(there's only one value of type <code>Promote x</code>: <code>promote x</code> -- hence why it's called a singleton).</p>
<p>Now the useful thing about this type is that it allows us to promote an arbitrary value to the type level, in particular we can promote an application of <code>suc</code> to a type variable:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_`div&#7510;`_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Promote</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div&#7510;`</span></span> <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div-suc`</span></span> <span class="agda2-highlight-bound-variable">m</span>
</pre>
<p>This ensures that the second argument is <code>promote</code> applied to a natural number and that natural number is of the <code>suc m</code> form for some <code>m</code>, which is exactly the invariant that we want to express. Note how Agda does not ask to handle a</p>
<pre><code>  n `divᵖ` promote 0 = ?</code></pre>
<p>case, as it knows that this case cannot occur.</p>
<p>We can check that the implicit <code>m</code> can be inferred without any problems:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Promote</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div&#7510;`</span></span> <span class="agda2-highlight-bound-variable">m</span>
</pre>
<p>which clearly has to be the case as <code>m</code> is an argument to a data constructor (<code>suc</code>) and the application (<code>suc m</code>) is an argument to a type constructor (<code>Promote</code>) and type and data constructors are inference-friendly due to them being invertible as we discussed before.</p>
<p>A test:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">List.map</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">`div&#7510;`</span></span> <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-number">4</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">8</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">10</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">11</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">12</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
    <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span>                                      <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">0</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span>  <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>An attempt to divide a number by <code>0</code> results in a somewhat readable type error (as opposed to an unsolved meta of type <code>⊥</code> as before):</p>
<pre><code>  -- zero !=&lt; suc _m_1287 of type ℕ
  -- when checking that the expression promote 0 has type
  -- Promote (suc _m_1287)
  _ : ∀ n -&gt; n `divᵖ` promote 0 ≡ n `divᵖ` promote 0
  _ = λ n -&gt; refl</code></pre>
<p>And we can of course provide a function that tries to parse a natural number as an application of <code>suc</code> and either fails (when the number is <code>0</code>) or returns a <code>Promote (suc m)</code> for some <code>m</code>:</p>
<pre>  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Product</span>

  <span class="agda2-highlight-function">parseNonZero</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Maybe</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">&#8707;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Promote</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8728;</span></span> <span class="agda2-highlight-inductive-constructor">suc</span><span class="agda2-highlight-symbol">))</span>
  <span class="agda2-highlight-function">parseNonZero</span>  <span class="agda2-highlight-inductive-constructor">zero</span>   <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">nothing</span>
  <span class="agda2-highlight-function">parseNonZero</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">just</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-symbol">_)</span>
</pre>
<p>Finally, there's one more use case for <code>promote</code>. Let's say you have some statically known list of numbers</p>
<pre>  <span class="agda2-highlight-function">listOfNumbers</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">List</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">listOfNumbers</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-inductive-constructor">[]</span>
</pre>
<p>and you want to extract the second number from the list. Direct pattern matching does not work:</p>
<pre>  <span class="agda2-highlight-function">secondNumber-direct</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">secondNumber-direct</span> <span class="agda2-highlight-keyword">with</span> <span class="agda2-highlight-function">listOfNumbers</span>
  <span class="agda2-highlight-symbol"><span class="agda2-highlight-coverage-problem">...</span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-coverage-problem">|</span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-coverage-problem">_</span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-coverage-problem">&#8759;</span></span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-bound-variable"><span class="agda2-highlight-coverage-problem">two</span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor"><span class="agda2-highlight-coverage-problem">&#8759;</span></span></span><span class="agda2-highlight-coverage-problem"> </span><span class="agda2-highlight-symbol"><span class="agda2-highlight-coverage-problem">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">two</span>
</pre>
<p>Agda colors the matching line, 'cause it wants you to handle the <code>[]</code> and <code>_ ∷ []</code> cases as well. This is because internally a <code>with</code>-abstraction is <a href="https://agda.readthedocs.io/en/v2.6.1/language/with-abstraction.html#helper-functions">translated to an auxiliary function</a> and the actual pattern matching happens in this function, but at that point we've already generalized the specific list to a variable of type <code>List ℕ</code> and lost the information that the original list (that gets passed as an argument to the function) is of a particular spine.</p>
<p>But we can preserve the information that the list is of a particular spine by reflecting that spine at the type level via <code>Promote</code>:</p>
<pre>  <span class="agda2-highlight-function">secondNumber</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">secondNumber</span> <span class="agda2-highlight-keyword">with</span> <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-function">listOfNumbers</span>
  <span class="agda2-highlight-symbol">...</span> <span class="agda2-highlight-symbol">|</span> <span class="agda2-highlight-inductive-constructor">promote</span> <span class="agda2-highlight-symbol">(_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-bound-variable">two</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;</span></span> <span class="agda2-highlight-symbol">_)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">two</span>
</pre>
<p>which makes Agda accept the definition.</p>
<h3 id="generating-type-level-data">Generating type-level data</h3>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">PolyvariadicZipWithNoGo</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Vec.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">Vec</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;&#7525;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">[]</span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<h4 id="polyvariadic-zipwith-a-no-go">Polyvariadic <code>zipWith</code>: a no go</h4>
<p>Recall this reasoning from the <code>PolyvariadicZipWith</code> module:</p>
<blockquote>
<p>We don't need <code>ToFun</code> to be invertible when the <em>spine</em> of <code>As</code> is provided explicitly:</p>
<pre><code>  _ : zipWithN {As = _ ∷ _ ∷ []} _+_ (1 ∷ᵥ 2 ∷ᵥ 3 ∷ᵥ []ᵥ) (4 ∷ᵥ 5 ∷ᵥ 6 ∷ᵥ []ᵥ) ≡ _
  _ = refl</code></pre>
<p>as Agda only needs to know the spine of <code>As</code> and not the actual types stored in the list in order for <code>ToFun</code> to compute (since <code>ToFun</code> is defined by pattern matching on the spine of its argument and so the actual elements of the list are computationally irrelevant). <code>ToFun (_A₁ ∷ _A₂ ∷ []) _B</code> computes to <code>_A₁ -&gt; _A₂ -&gt; _B</code> and unifying that type with <code>ℕ -&gt; ℕ -&gt; ℕ</code> is a trivial task.</p>
</blockquote>
<p>Can we somehow make that more ergonomic and allow the user to specify the length of the list of types (i.e. just a number) instead of the spine of that list, which is awkward? One option is to still use a list of types, but provide a wrapper that receives a natural number and turns every <code>suc</code> into a <code>∀</code> binding a type. All types bound this way then get fed one by one to a continuation that assembles them in a list and once <code>zero</code> is reached the wrapper calls the original function and passes the collected list of types as an argument. This is what they do in the <a href="http://www.seas.upenn.edu/~sweirich/papers/aritygen.pdf">Arity-Generic Datatype-Generic Programming</a> paper. However this approach is rather tedious as it introduces a level of indirection that makes it harder to prove things about n-ary functions defined this way (and generally handle them at the type level). It also doesn't play well with universe polymorphism, since in order to handle an n-ary function receiving arguments lying in different universes we need another data structure storing the level of each of the universes and making that structure also a list entails the necessity to provide another wrapper on top of the existing one, which is just a mess.</p>
<p>One idea that comes to mind is to store types in a vector rather than a list. A vector is indexed by its length, so if we explicitly provide the length of a vector, Agda will be able to infer its spine and we won't need to specify it explicitly, right? Not quite.</p>
<p>Having these definitions:</p>
<pre>  <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ToFun&#7525;</span>  <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>      <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>

  <span class="agda2-highlight-function">idN&#7525;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">idN&#7525;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>(<code>idNᵥ</code> receives an n-ary function and returns it back. <code>n</code> specifies how many arguments that function takes) we can check if <code>As</code> is inferrable in <code>idNᵥ</code>:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function"><span class="agda2-highlight-unsolved-meta">idN&#7525;</span></span><span class="agda2-highlight-unsolved-meta"> </span><span class="agda2-highlight-number"><span class="agda2-highlight-unsolved-meta">2</span></span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive"><span class="agda2-highlight-unsolved-meta"><span class="agda2-highlight-unsolved-constraint">_+_</span></span></span></span>
</pre>
<p>Nope, it's not. Even though we know that we've specified enough information to determine what <code>As</code> is, we see yellow nevertheless. But if the spine of <code>As</code> is provided explicitly, then everything type checks:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idN&#7525;</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-symbol">{_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span>
</pre>
<p>&quot;But <code>2</code> determines that spine!&quot; -- well, yes, but Agda doesn't see that.</p>
<p>We can force Agda to infer the spine of the vector by using a constructor-headed function matching on the vector and returning its length. We then need to equate the result of that function with the actual length provided as the <code>n</code> argument. The function looks like this:</p>
<pre>  <span class="agda2-highlight-function">length-deep</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span>
  <span class="agda2-highlight-function">length-deep</span>  <span class="agda2-highlight-inductive-constructor">[]&#7525;</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-number">0</span>
  <span class="agda2-highlight-function">length-deep</span> <span class="agda2-highlight-symbol">(_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">length-deep</span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>The idea is that since we know the length of the vector (by means of it being provided as an argument) and <code>length-deep</code> returns precisely that length, we can make Agda invert the constructor-headed <code>length-deep</code> (and thus infer the spine of the vector) by unifying the provided and the computed lengths. However that last unification part is tricky: in Haskell one can just use <code>~</code> (see <a href="https://downloads.haskell.org/~ghc/8.8.4/docs/html/users_guide/glasgow_exts.html#equality-constraints">GHC User's Guide</a>) and that will force unification at the call site (or require the constraint to bubble up), but Agda doesn't seem to have an analogous primitive. We can cook it up from instance arguments though, but first here's an explicit version:</p>
<pre>  <span class="agda2-highlight-function">idN&#7525;&#8337;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">length-deep</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">idN&#7525;&#8337;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p><code>idNᵥₑ</code> does not use the equality proof that it asks for, but the caller has to provide a proof anyway and so <code>refl</code> provided as a proof will force unification of <code>length-deep As</code> and <code>n</code> as Agda has to check that those two terms are actually the same thing (as <code>refl</code> claims them to be). And this unification is the only thing we need to get <code>length-deep</code> inverted and thus the spine of <code>As</code> inferred. We can check that there's indeed no yellow now:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idN&#7525;&#8337;</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-inductive-constructor">refl</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span>
</pre>
<p>Of course providing <code>refl</code> manually is laborious and since it's the only constructor of <code>_≡_</code> we can ask Agda to come up with it automatically via instance arguments:</p>
<pre>  <span class="agda2-highlight-function">idN&#7525;&#7522;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">{{</span><span class="agda2-highlight-function">length-deep</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun&#7525;</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">idN&#7525;&#7522;</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>
</pre>
<p>It's nearly the same function as the previous one, but now Agda implicitly inserts <code>refl</code> instead of asking the user to insert it explicitly. A test:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idN&#7525;&#7522;</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span>
</pre>
<p>Summarizing, <code>Vec</code> is as inference-friendly as <code>List</code> (i.e. not very friendly) when it comes to n-ary operations (we could use the same equate-the-expected-length-with-the-provided-one trick for <code>List</code> as well). And it's also impossible to store types from different universes in a <code>Vec</code>.</p>
<p>But there's a better way to store types.</p>
<h4 id="polyvariadic-zipwith-eta-based">Polyvariadic <code>zipWith</code>: eta-based</h4>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">PolyvariadicZipWithEtaBased</span> <span class="agda2-highlight-keyword">where</span>
  <span class="agda2-highlight-keyword">open</span> <span class="agda2-highlight-keyword">import</span> <span class="agda2-highlight-module">Data.Vec.Base</span> <span class="agda2-highlight-symbol">as</span> <span class="agda2-highlight-module">Vec</span> <span class="agda2-highlight-keyword">renaming</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;_</span></span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">_&#8759;&#7525;_</span></span><span class="agda2-highlight-symbol">;</span> <span class="agda2-highlight-inductive-constructor">[]</span> <span class="agda2-highlight-symbol">to</span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Here's an inference-friendly data structure:</p>
<pre>  <span class="comment">-- Same as `&#8868;`, but lives in `Set&#8321;` rather than `Set`.</span>
  <span class="agda2-highlight-keyword">record</span> <span class="agda2-highlight-record">&#8868;&#8321;</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-primitive-type">Set&#8321;</span> <span class="agda2-highlight-keyword">where</span>
    <span class="agda2-highlight-keyword">constructor</span> <span class="agda2-highlight-inductive-constructor">tt&#8321;</span>

  <span class="comment">-- This function is constructor-headed.</span>
  <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set&#8321;</span>
  <span class="agda2-highlight-function">Sets</span>  <span class="agda2-highlight-number">0</span>      <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-record">&#8868;&#8321;</span>
  <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#215;</span></span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span>
</pre>
<p><code>Sets n</code> computes to the <code>n</code>-ary product of <code>Set</code>s, for example <code>Sets 3</code> reduces to <code>Set × Set × Set × ⊤₁</code>. I.e. <code>Sets n</code> is isomorphic to <code>Vec Set n</code>, but since the former computes to a bunch of products and Agda has eta-rules for those, inferring a whole <code>Sets n</code> value amounts only to inferring each particular type from that structure, which is not the case for <code>Vec Set n</code> as we've seen previously (we know that <code>n</code> does determine the spine of a <code>Vec</code>, but Agda does not attempt to infer that spine).</p>
<p>Here's a quick test that <code>Sets</code> does have better inference properties than <code>Vec</code>:</p>
<pre>  <span class="comment">-- `n` can be inferred from `Sets n`, hence can be left it implicit.</span>
  <span class="comment">-- As before, this function is constructor/argument-headed.</span>
  <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-number">0</span><span class="agda2-highlight-symbol">}</span>      <span class="agda2-highlight-inductive-constructor">tt&#8321;</span>     <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>

  <span class="agda2-highlight-function">idN</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span>
  <span class="agda2-highlight-function">idN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-bound-variable">y</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">y</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">idN</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span>
</pre>
<p>Type checks perfectly.</p>
<p>Now we can proceed to defining <code>Sets</code>-based polyvariadic <code>zipWith</code>. For that we'll neeed a way to map elements of a <code>Sets</code> with a function:</p>
<pre>  <span class="comment">-- This function is constructor-headed as its `Vec`-based analogue.</span>
  <span class="agda2-highlight-function">mapSets</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span>
  <span class="agda2-highlight-function">mapSets</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-number">0</span><span class="agda2-highlight-symbol">}</span>     <span class="agda2-highlight-bound-variable">F</span>  <span class="agda2-highlight-inductive-constructor">tt&#8321;</span>     <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">tt&#8321;</span>
  <span class="agda2-highlight-function">mapSets</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-function">mapSets</span> <span class="agda2-highlight-bound-variable">F</span> <span class="agda2-highlight-bound-variable">As</span>
</pre>
<p>And the rest is the same as the previous version except <code>List</code> is replaced by <code>Sets n</code>:</p>
<pre>  <span class="comment">-- As before, even though this function delegates to `ToFun`, it's constructor-headed</span>
  <span class="comment">-- (as opposed to the constructor/argument-headed `ToFun`), because the `B` of `ToFun` gets</span>
  <span class="comment">-- instantiated with `Vec B m` and so the two clauses of `ToFun` become disjoint (because `Vec`</span>
  <span class="comment">-- and `-&gt;` are two distinct type constructors).</span>
  <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">&#8469;</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">mapSets</span> <span class="agda2-highlight-symbol">(&#955;</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">A</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">As</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">)</span>

  <span class="comment">-- Here `Sets n` is implicit, so in order to infer `n` from it, Agda needs to be able to infer</span>
  <span class="comment">-- `As`. As before, it's not possible to infer `As` from the type of the argument, but is</span>
  <span class="comment">-- possible to infer it from the type of the result.</span>
  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-datatype">Vec</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-bound-variable">m</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-number">0</span><span class="agda2-highlight-symbol">}</span>     <span class="agda2-highlight-bound-variable">ys</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">ys</span>
  <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-bound-variable">fs</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">&#955;</span> <span class="agda2-highlight-bound-variable">xs</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">zipWith</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_$_</span></span> <span class="agda2-highlight-bound-variable">fs</span> <span class="agda2-highlight-bound-variable">xs</span><span class="agda2-highlight-symbol">)</span>

  <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-bound-variable">n</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">Sets</span> <span class="agda2-highlight-bound-variable">n</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-function">ToVecFun</span> <span class="agda2-highlight-bound-variable">As</span> <span class="agda2-highlight-bound-variable">B</span> <span class="agda2-highlight-bound-variable">m</span>
  <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-bound-variable">f</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-function">apN</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-function">Vec.replicate</span> <span class="agda2-highlight-bound-variable">f</span><span class="agda2-highlight-symbol">)</span>
</pre>
<p>Note that <code>n</code> is an explicit argument in <code>zipWithN</code>. Providing <code>n</code> explicitly is useful when <code>As</code> can't be inferred otherwise. We'll consider such cases, but first let's check that all previous tests still pass. No need to specify <code>n</code> when when all arguments and the result are explicitly provided (which makes it possible for Agda to invert <code>ToVecFun</code> and infer <code>As</code>, as before)</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">7</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">9</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>No need to specify <code>n</code> when either <code>B</code> or the spine of <code>As</code> is specified (which makes it possible for Agda to invert <code>ToFun</code> and infer <code>As</code>, as before)</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">{</span>B <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-datatype">&#8469;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">{</span>As <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">,</span></span> <span class="agda2-highlight-inductive-constructor">tt&#8321;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>I.e. the <code>Sets</code>-based <code>zipWithN</code> is at least as good inference-wise as its <code>List</code>-based counterpart. But now we can also just specify the arity (<code>n</code>) of the zipping function without specifying <code>B</code> or the spine of <code>As</code> as the spine of <code>As</code> can be inferred from <code>n</code> due to <code>Sets</code> being defined by pattern matching on <code>n</code> and computing to an <code>n</code>-ary product (which is inference-friendly due to the eta-rule of <code>_×_</code>):</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-number">1</span> <span class="agda2-highlight-inductive-constructor">suc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-function">zipWithN</span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">_+_</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">1</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">2</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">3</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-number">4</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">5</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-number">6</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-inductive-constructor">&#8759;&#7525;</span></span> <span class="agda2-highlight-inductive-constructor">[]&#7525;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-symbol">_</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>This approach generalizes to dependently typed functions as well as full universe polymorpism, see <a href="https://stackoverflow.com/q/29179508/3237465">this Stack Overflow question and answer</a> for an elaborated example. And it's possible to write a general machinery that supports both non-dependent and dependent n-ary functions, see this <a href="http://effectfully.blogspot.com/2016/04/generic-universe-polymorphic.html">blog post</a>.</p>
<h2 id="universe-levels">Universe levels</h2>
<pre><span class="agda2-highlight-keyword">module</span> <span class="agda2-highlight-module">UniverseLevels</span> <span class="agda2-highlight-keyword">where</span>
</pre>
<p>There are a bunch of definitional equalities associated with universe levels. Without them universe polymorphism would be nearly unusable. Here are the equalities:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive">lzero</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#945;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-bound-variable">&#947;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#947;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#947;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>

  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">)</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>A demonstration of how Agda can greatly simplify level expressions using the above identites:</p>
<pre>  <span class="agda2-highlight-symbol"><span class="agda2-highlight-function">_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-symbol">&#8704;</span> <span class="agda2-highlight-symbol">{</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-bound-variable">&#947;</span><span class="agda2-highlight-symbol">}</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#947;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">))</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-primitive">lzero</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#947;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-symbol">(</span><span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-primitive">lsuc</span> <span class="agda2-highlight-bound-variable">&#946;</span><span class="agda2-highlight-symbol">)</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#947;</span>
  <span class="agda2-highlight-symbol">_</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-inductive-constructor">refl</span>
</pre>
<p>These special rules also give us the ability to define a less-than-or-equal-to relation on levels:</p>
<pre>  <span class="agda2-highlight-operator"><span class="agda2-highlight-function">_&#8804;&#8467;_</span></span> <span class="agda2-highlight-symbol">:</span> <span class="agda2-highlight-postulate">Level</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-postulate">Level</span> <span class="agda2-highlight-symbol">-&gt;</span> <span class="agda2-highlight-primitive-type">Set</span>
  <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-function">&#8804;&#8467;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-symbol">=</span> <span class="agda2-highlight-bound-variable">&#945;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-primitive">&#8852;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span> <span class="agda2-highlight-operator"><span class="agda2-highlight-datatype">&#8801;</span></span> <span class="agda2-highlight-bound-variable">&#946;</span>
</pre>
<p>which in turn allows us to <a href="http://effectfully.blogspot.com/2016/07/cumu.html">emulate cumulativity of universes</a> in Agda (although there is an experimental option <a href="https://agda.readthedocs.io/en/latest/language/cumulativity.html"><code>--cumulativity</code></a> that makes the universe hierarchy cumulative).</p>
<p>The list of equalities shown above is not exhaustive. E.g. if during type checking Agda comes up with the following constraint:</p>
<pre><code>  α &lt;= β &lt;= α</code></pre>
<p>it gets solved as <code>α ≡ β</code>.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Huge &quot;thank you&quot; goes to major contributors:</p>
<ul>
<li>Andreas Abel
</pre>
</body>
</html></li>
</ul>
</body>
</html>
